<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.training.filter_manager API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.training.filter_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterManager:
    
    &#34;&#34;&#34;
    Class implementing 3 filtering methods: \n
        - Filter by IOU \n
        - Filter bounding contains inside another \n
        - Filter by score
    &#34;&#34;&#34;
    @staticmethod
    def compute_interArea(boxA, boxB):
        &#34;&#34;&#34;
        Compute the intersection area of two bounding boxes `boxA` and `boxB`
        &#34;&#34;&#34;
        # determine the (x, y)-coordinates of the intersection rectangle
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])

        # compute the area of intersection rectangle
        interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)

        return interArea

    @staticmethod
    def compute_area(box):
        &#34;&#34;&#34;
        Computes the area of a bounding box `box`
        &#34;&#34;&#34;
        boxArea = (box[2] - box[0] + 1) * (box[3] - box[1] + 1)
        return boxArea

    @staticmethod
    def bb_intersection_over_union(boxA, boxB):
        &#34;&#34;&#34;
        Computes the IOU of two bounding boxes `boxA` and `boxB`
        &#34;&#34;&#34;
        interArea = FilterManager.compute_interArea(boxA, boxB)

        boxAArea = FilterManager.compute_area(boxA)
        boxBArea = FilterManager.compute_area(boxB)

        # compute the intersection over union by taking the intersection
        # area and dividing it by the sum of prediction + ground-truth
        # areas - the interesection area
        iou = interArea / float(boxAArea + boxBArea - interArea)

        # return the intersection over union value
        return iou

    @staticmethod
    def filter_by_iou(bboxes, class_ids, scores, threshold_iou=0.5, threshold_area=0.8):
        &#34;&#34;&#34;
        Filter the predicted bounding boxes overlapping of more than `threshold_iou` (default:50%)\n
        Keep only the bounding box with the highest score\n

        If IOU is below 0.5, check if one box in contained inside another other \n
        if the area of the intersection is above `threshold_area` (default:80%) of the area of one of the bon
        Keep the one with the highest score \n

        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `threshold_iou`: the IOU threshold\n
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
        &#34;&#34;&#34;
        added = [False]*len(bboxes)
        new_bboxes = []
        new_class_ids = []
        new_scores = []

        for i in range(len(bboxes)):
            boxA = bboxes[i]
            scoreA = scores[i]

            box_added = False

            for j in range(i+1, len(bboxes)):
                boxB = bboxes[j]
                scoreB = scores[j]

                interArea = FilterManager.compute_interArea(boxA, boxB)
                boxAArea = FilterManager.compute_area(boxA)
                boxBArea = FilterManager.compute_area(boxB)

                # compute the intersection over union by taking the intersection
                # area and dividing it by the sum of prediction + ground-truth
                # areas - the interesection area
                iou = interArea / float(boxAArea + boxBArea - interArea)

                # check threshold or if one is inside another
                if iou &gt; threshold_iou or interArea &gt; boxAArea*threshold_area or interArea &gt; boxBArea*threshold_area:
                    # keep only the one with the biggest score
                    if scoreA &gt; scoreB:
                        if not added[i]:
                            new_bboxes.append(boxA)
                            new_class_ids.append(class_ids[i])
                            new_scores.append(scores[i])
                            added[i] = True
                            added[j] = True
                            box_added = True
                    else:
                        if not added[j]:
                            new_bboxes.append(boxB)
                            new_class_ids.append(class_ids[j])
                            new_scores.append(scores[j])
                            added[i] = True
                            added[j] = True
                            box_added = True

            # if not found overlapping bboxes, add it
            if not box_added and not added[i]:
                new_bboxes.append(boxA)
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
                added[i] = True

        return new_bboxes, new_class_ids, new_scores

    @staticmethod
    def filter_contains(bboxes, class_ids, scores, mode=&#34;biggest&#34;):
        &#34;&#34;&#34;
        Filter the box contained inside another \n
        Keep the boxes with the highest score or the biggest \n
        
        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `mode`: &#34;highest&#34; / &#34;biggest&#34; \n
        
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
       
        &#34;&#34;&#34;

        added = [False]*len(bboxes)
        new_bboxes = []
        new_class_ids = []
        new_scores = []

        for i in range(len(bboxes)):
            boxA = bboxes[i]
            scoreA = scores[i]

            box_added = False

            for j in range(i+1, len(bboxes)):
                boxB = bboxes[j]
                scoreB = scores[j]

                contains = -1
                # if boxA is contained inside boxB
                if boxA[0] &gt; boxB[0] and boxA[1] &gt; boxB[1] and boxA[2] &lt; boxB[2] and boxA[3] &lt; boxB[3]:
                    contains = 0
                # if boxB is contained inside boxA
                elif boxA[0] &lt; boxB[0] and boxA[1] &lt; boxB[1] and boxA[2] &gt; boxB[2] and boxA[3] &gt; boxB[3]:
                    contains = 1

                if contains != -1:
                    if mode == &#34;highest&#34;:
                        # keep only the one with the biggest score
                        if scoreA &gt; scoreB:
                            if not added[i]:
                                new_bboxes.append(boxA)
                                new_class_ids.append(class_ids[i])
                                new_scores.append(scores[i])
                                added[i] = True
                                added[j] = True
                                box_added = True
                        else:
                            if not added[j]:
                                new_bboxes.append(boxB)
                                new_class_ids.append(class_ids[j])
                                new_scores.append(scores[j])
                                added[i] = True
                                added[j] = True
                                box_added = True
                    elif mode == &#34;biggest&#34;:
                        if contains == 0:
                            if not added[j]:
                                new_bboxes.append(boxB)
                                new_class_ids.append(class_ids[j])
                                new_scores.append(scores[j])
                                added[j] = True
                                added[i] = True
                                box_added = True
                        elif contains == 1:
                            if not added[i]:
                                new_bboxes.append(boxA)
                                new_class_ids.append(class_ids[i])
                                new_scores.append(scores[i])
                                added[i] = True
                                added[j] = True
                                box_added = True

            # if not found overlapping bboxes, add it
            if not box_added and not added[i]:
                new_bboxes.append(boxA)
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
                added[i] = True

        return new_bboxes, new_class_ids, new_scores

    @staticmethod
    def filter_by_scores(bboxes, class_ids, scores, threshold=0.995, threshold_validation=None, scores_validation=None):
        &#34;&#34;&#34;
        Filter all the predicted bounding boxes below a certain threshold
        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `threshold`: float, score threshold \n
        `threshold_validation`: boolean to activate the score filtering using the second model validation of the bounding box\n
        `scores_validation`: float, score threshold \n
        
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
        &#34;&#34;&#34;
        new_bboxes = []
        new_class_ids = []
        new_scores = []
        for i in range(len(scores)):
            if scores[i] &lt; threshold:
                continue
            else:
                if threshold_validation:
                    if scores_validation[i] &lt; threshold_validation:
                        continue
                new_bboxes.append(bboxes[i])
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
        return new_bboxes, new_class_ids, new_scores</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helipad_detection.src.training.filter_manager.FilterManager"><code class="flex name class">
<span>class <span class="ident">FilterManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class implementing 3 filtering methods: </p>
<pre><code>- Filter by IOU

- Filter bounding contains inside another

- Filter by score
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterManager:
    
    &#34;&#34;&#34;
    Class implementing 3 filtering methods: \n
        - Filter by IOU \n
        - Filter bounding contains inside another \n
        - Filter by score
    &#34;&#34;&#34;
    @staticmethod
    def compute_interArea(boxA, boxB):
        &#34;&#34;&#34;
        Compute the intersection area of two bounding boxes `boxA` and `boxB`
        &#34;&#34;&#34;
        # determine the (x, y)-coordinates of the intersection rectangle
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])

        # compute the area of intersection rectangle
        interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)

        return interArea

    @staticmethod
    def compute_area(box):
        &#34;&#34;&#34;
        Computes the area of a bounding box `box`
        &#34;&#34;&#34;
        boxArea = (box[2] - box[0] + 1) * (box[3] - box[1] + 1)
        return boxArea

    @staticmethod
    def bb_intersection_over_union(boxA, boxB):
        &#34;&#34;&#34;
        Computes the IOU of two bounding boxes `boxA` and `boxB`
        &#34;&#34;&#34;
        interArea = FilterManager.compute_interArea(boxA, boxB)

        boxAArea = FilterManager.compute_area(boxA)
        boxBArea = FilterManager.compute_area(boxB)

        # compute the intersection over union by taking the intersection
        # area and dividing it by the sum of prediction + ground-truth
        # areas - the interesection area
        iou = interArea / float(boxAArea + boxBArea - interArea)

        # return the intersection over union value
        return iou

    @staticmethod
    def filter_by_iou(bboxes, class_ids, scores, threshold_iou=0.5, threshold_area=0.8):
        &#34;&#34;&#34;
        Filter the predicted bounding boxes overlapping of more than `threshold_iou` (default:50%)\n
        Keep only the bounding box with the highest score\n

        If IOU is below 0.5, check if one box in contained inside another other \n
        if the area of the intersection is above `threshold_area` (default:80%) of the area of one of the bon
        Keep the one with the highest score \n

        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `threshold_iou`: the IOU threshold\n
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
        &#34;&#34;&#34;
        added = [False]*len(bboxes)
        new_bboxes = []
        new_class_ids = []
        new_scores = []

        for i in range(len(bboxes)):
            boxA = bboxes[i]
            scoreA = scores[i]

            box_added = False

            for j in range(i+1, len(bboxes)):
                boxB = bboxes[j]
                scoreB = scores[j]

                interArea = FilterManager.compute_interArea(boxA, boxB)
                boxAArea = FilterManager.compute_area(boxA)
                boxBArea = FilterManager.compute_area(boxB)

                # compute the intersection over union by taking the intersection
                # area and dividing it by the sum of prediction + ground-truth
                # areas - the interesection area
                iou = interArea / float(boxAArea + boxBArea - interArea)

                # check threshold or if one is inside another
                if iou &gt; threshold_iou or interArea &gt; boxAArea*threshold_area or interArea &gt; boxBArea*threshold_area:
                    # keep only the one with the biggest score
                    if scoreA &gt; scoreB:
                        if not added[i]:
                            new_bboxes.append(boxA)
                            new_class_ids.append(class_ids[i])
                            new_scores.append(scores[i])
                            added[i] = True
                            added[j] = True
                            box_added = True
                    else:
                        if not added[j]:
                            new_bboxes.append(boxB)
                            new_class_ids.append(class_ids[j])
                            new_scores.append(scores[j])
                            added[i] = True
                            added[j] = True
                            box_added = True

            # if not found overlapping bboxes, add it
            if not box_added and not added[i]:
                new_bboxes.append(boxA)
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
                added[i] = True

        return new_bboxes, new_class_ids, new_scores

    @staticmethod
    def filter_contains(bboxes, class_ids, scores, mode=&#34;biggest&#34;):
        &#34;&#34;&#34;
        Filter the box contained inside another \n
        Keep the boxes with the highest score or the biggest \n
        
        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `mode`: &#34;highest&#34; / &#34;biggest&#34; \n
        
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
       
        &#34;&#34;&#34;

        added = [False]*len(bboxes)
        new_bboxes = []
        new_class_ids = []
        new_scores = []

        for i in range(len(bboxes)):
            boxA = bboxes[i]
            scoreA = scores[i]

            box_added = False

            for j in range(i+1, len(bboxes)):
                boxB = bboxes[j]
                scoreB = scores[j]

                contains = -1
                # if boxA is contained inside boxB
                if boxA[0] &gt; boxB[0] and boxA[1] &gt; boxB[1] and boxA[2] &lt; boxB[2] and boxA[3] &lt; boxB[3]:
                    contains = 0
                # if boxB is contained inside boxA
                elif boxA[0] &lt; boxB[0] and boxA[1] &lt; boxB[1] and boxA[2] &gt; boxB[2] and boxA[3] &gt; boxB[3]:
                    contains = 1

                if contains != -1:
                    if mode == &#34;highest&#34;:
                        # keep only the one with the biggest score
                        if scoreA &gt; scoreB:
                            if not added[i]:
                                new_bboxes.append(boxA)
                                new_class_ids.append(class_ids[i])
                                new_scores.append(scores[i])
                                added[i] = True
                                added[j] = True
                                box_added = True
                        else:
                            if not added[j]:
                                new_bboxes.append(boxB)
                                new_class_ids.append(class_ids[j])
                                new_scores.append(scores[j])
                                added[i] = True
                                added[j] = True
                                box_added = True
                    elif mode == &#34;biggest&#34;:
                        if contains == 0:
                            if not added[j]:
                                new_bboxes.append(boxB)
                                new_class_ids.append(class_ids[j])
                                new_scores.append(scores[j])
                                added[j] = True
                                added[i] = True
                                box_added = True
                        elif contains == 1:
                            if not added[i]:
                                new_bboxes.append(boxA)
                                new_class_ids.append(class_ids[i])
                                new_scores.append(scores[i])
                                added[i] = True
                                added[j] = True
                                box_added = True

            # if not found overlapping bboxes, add it
            if not box_added and not added[i]:
                new_bboxes.append(boxA)
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
                added[i] = True

        return new_bboxes, new_class_ids, new_scores

    @staticmethod
    def filter_by_scores(bboxes, class_ids, scores, threshold=0.995, threshold_validation=None, scores_validation=None):
        &#34;&#34;&#34;
        Filter all the predicted bounding boxes below a certain threshold
        `bboxes`: a list of bounding boxes\n
        `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
        `scores`: a list of confidence scores corresponding to the bounding boxes\n
        `threshold`: float, score threshold \n
        `threshold_validation`: boolean to activate the score filtering using the second model validation of the bounding box\n
        `scores_validation`: float, score threshold \n
        
        Return \n
        `new_bboxes`: filtered bounding boxes
        `new_class_ids`: filtered class id
        `new_scores`: filtered confidence score
        &#34;&#34;&#34;
        new_bboxes = []
        new_class_ids = []
        new_scores = []
        for i in range(len(scores)):
            if scores[i] &lt; threshold:
                continue
            else:
                if threshold_validation:
                    if scores_validation[i] &lt; threshold_validation:
                        continue
                new_bboxes.append(bboxes[i])
                new_class_ids.append(class_ids[i])
                new_scores.append(scores[i])
        return new_bboxes, new_class_ids, new_scores</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.bb_intersection_over_union"><code class="name flex">
<span>def <span class="ident">bb_intersection_over_union</span></span>(<span>boxA, boxB)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the IOU of two bounding boxes <code>boxA</code> and <code>boxB</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def bb_intersection_over_union(boxA, boxB):
    &#34;&#34;&#34;
    Computes the IOU of two bounding boxes `boxA` and `boxB`
    &#34;&#34;&#34;
    interArea = FilterManager.compute_interArea(boxA, boxB)

    boxAArea = FilterManager.compute_area(boxA)
    boxBArea = FilterManager.compute_area(boxB)

    # compute the intersection over union by taking the intersection
    # area and dividing it by the sum of prediction + ground-truth
    # areas - the interesection area
    iou = interArea / float(boxAArea + boxBArea - interArea)

    # return the intersection over union value
    return iou</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.compute_area"><code class="name flex">
<span>def <span class="ident">compute_area</span></span>(<span>box)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the area of a bounding box <code>box</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compute_area(box):
    &#34;&#34;&#34;
    Computes the area of a bounding box `box`
    &#34;&#34;&#34;
    boxArea = (box[2] - box[0] + 1) * (box[3] - box[1] + 1)
    return boxArea</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.compute_interArea"><code class="name flex">
<span>def <span class="ident">compute_interArea</span></span>(<span>boxA, boxB)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection area of two bounding boxes <code>boxA</code> and <code>boxB</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compute_interArea(boxA, boxB):
    &#34;&#34;&#34;
    Compute the intersection area of two bounding boxes `boxA` and `boxB`
    &#34;&#34;&#34;
    # determine the (x, y)-coordinates of the intersection rectangle
    xA = max(boxA[0], boxB[0])
    yA = max(boxA[1], boxB[1])
    xB = min(boxA[2], boxB[2])
    yB = min(boxA[3], boxB[3])

    # compute the area of intersection rectangle
    interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)

    return interArea</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.filter_by_iou"><code class="name flex">
<span>def <span class="ident">filter_by_iou</span></span>(<span>bboxes, class_ids, scores, threshold_iou=0.5, threshold_area=0.8)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the predicted bounding boxes overlapping of more than <code>threshold_iou</code> (default:50%)</p>
<p>Keep only the bounding box with the highest score</p>
<p>If IOU is below 0.5, check if one box in contained inside another other </p>
<p>if the area of the intersection is above <code>threshold_area</code> (default:80%) of the area of one of the bon
Keep the one with the highest score </p>
<p><code>bboxes</code>: a list of bounding boxes</p>
<p><code>class_ids</code>: a list of class ids (0 or 1) corresponding to the bounding boxes</p>
<p><code>scores</code>: a list of confidence scores corresponding to the bounding boxes</p>
<p><code>threshold_iou</code>: the IOU threshold</p>
<p>Return </p>
<p><code>new_bboxes</code>: filtered bounding boxes
<code>new_class_ids</code>: filtered class id
<code>new_scores</code>: filtered confidence score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def filter_by_iou(bboxes, class_ids, scores, threshold_iou=0.5, threshold_area=0.8):
    &#34;&#34;&#34;
    Filter the predicted bounding boxes overlapping of more than `threshold_iou` (default:50%)\n
    Keep only the bounding box with the highest score\n

    If IOU is below 0.5, check if one box in contained inside another other \n
    if the area of the intersection is above `threshold_area` (default:80%) of the area of one of the bon
    Keep the one with the highest score \n

    `bboxes`: a list of bounding boxes\n
    `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
    `scores`: a list of confidence scores corresponding to the bounding boxes\n
    `threshold_iou`: the IOU threshold\n
    Return \n
    `new_bboxes`: filtered bounding boxes
    `new_class_ids`: filtered class id
    `new_scores`: filtered confidence score
    &#34;&#34;&#34;
    added = [False]*len(bboxes)
    new_bboxes = []
    new_class_ids = []
    new_scores = []

    for i in range(len(bboxes)):
        boxA = bboxes[i]
        scoreA = scores[i]

        box_added = False

        for j in range(i+1, len(bboxes)):
            boxB = bboxes[j]
            scoreB = scores[j]

            interArea = FilterManager.compute_interArea(boxA, boxB)
            boxAArea = FilterManager.compute_area(boxA)
            boxBArea = FilterManager.compute_area(boxB)

            # compute the intersection over union by taking the intersection
            # area and dividing it by the sum of prediction + ground-truth
            # areas - the interesection area
            iou = interArea / float(boxAArea + boxBArea - interArea)

            # check threshold or if one is inside another
            if iou &gt; threshold_iou or interArea &gt; boxAArea*threshold_area or interArea &gt; boxBArea*threshold_area:
                # keep only the one with the biggest score
                if scoreA &gt; scoreB:
                    if not added[i]:
                        new_bboxes.append(boxA)
                        new_class_ids.append(class_ids[i])
                        new_scores.append(scores[i])
                        added[i] = True
                        added[j] = True
                        box_added = True
                else:
                    if not added[j]:
                        new_bboxes.append(boxB)
                        new_class_ids.append(class_ids[j])
                        new_scores.append(scores[j])
                        added[i] = True
                        added[j] = True
                        box_added = True

        # if not found overlapping bboxes, add it
        if not box_added and not added[i]:
            new_bboxes.append(boxA)
            new_class_ids.append(class_ids[i])
            new_scores.append(scores[i])
            added[i] = True

    return new_bboxes, new_class_ids, new_scores</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.filter_by_scores"><code class="name flex">
<span>def <span class="ident">filter_by_scores</span></span>(<span>bboxes, class_ids, scores, threshold=0.995, threshold_validation=None, scores_validation=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter all the predicted bounding boxes below a certain threshold
<code>bboxes</code>: a list of bounding boxes</p>
<p><code>class_ids</code>: a list of class ids (0 or 1) corresponding to the bounding boxes</p>
<p><code>scores</code>: a list of confidence scores corresponding to the bounding boxes</p>
<p><code>threshold</code>: float, score threshold </p>
<p><code>threshold_validation</code>: boolean to activate the score filtering using the second model validation of the bounding box</p>
<p><code>scores_validation</code>: float, score threshold </p>
<p>Return </p>
<p><code>new_bboxes</code>: filtered bounding boxes
<code>new_class_ids</code>: filtered class id
<code>new_scores</code>: filtered confidence score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def filter_by_scores(bboxes, class_ids, scores, threshold=0.995, threshold_validation=None, scores_validation=None):
    &#34;&#34;&#34;
    Filter all the predicted bounding boxes below a certain threshold
    `bboxes`: a list of bounding boxes\n
    `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
    `scores`: a list of confidence scores corresponding to the bounding boxes\n
    `threshold`: float, score threshold \n
    `threshold_validation`: boolean to activate the score filtering using the second model validation of the bounding box\n
    `scores_validation`: float, score threshold \n
    
    Return \n
    `new_bboxes`: filtered bounding boxes
    `new_class_ids`: filtered class id
    `new_scores`: filtered confidence score
    &#34;&#34;&#34;
    new_bboxes = []
    new_class_ids = []
    new_scores = []
    for i in range(len(scores)):
        if scores[i] &lt; threshold:
            continue
        else:
            if threshold_validation:
                if scores_validation[i] &lt; threshold_validation:
                    continue
            new_bboxes.append(bboxes[i])
            new_class_ids.append(class_ids[i])
            new_scores.append(scores[i])
    return new_bboxes, new_class_ids, new_scores</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.training.filter_manager.FilterManager.filter_contains"><code class="name flex">
<span>def <span class="ident">filter_contains</span></span>(<span>bboxes, class_ids, scores, mode='biggest')</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the box contained inside another </p>
<p>Keep the boxes with the highest score or the biggest </p>
<p><code>bboxes</code>: a list of bounding boxes</p>
<p><code>class_ids</code>: a list of class ids (0 or 1) corresponding to the bounding boxes</p>
<p><code>scores</code>: a list of confidence scores corresponding to the bounding boxes</p>
<p><code>mode</code>: "highest" / "biggest" </p>
<p>Return </p>
<p><code>new_bboxes</code>: filtered bounding boxes
<code>new_class_ids</code>: filtered class id
<code>new_scores</code>: filtered confidence score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def filter_contains(bboxes, class_ids, scores, mode=&#34;biggest&#34;):
    &#34;&#34;&#34;
    Filter the box contained inside another \n
    Keep the boxes with the highest score or the biggest \n
    
    `bboxes`: a list of bounding boxes\n
    `class_ids`: a list of class ids (0 or 1) corresponding to the bounding boxes\n
    `scores`: a list of confidence scores corresponding to the bounding boxes\n
    `mode`: &#34;highest&#34; / &#34;biggest&#34; \n
    
    Return \n
    `new_bboxes`: filtered bounding boxes
    `new_class_ids`: filtered class id
    `new_scores`: filtered confidence score
   
    &#34;&#34;&#34;

    added = [False]*len(bboxes)
    new_bboxes = []
    new_class_ids = []
    new_scores = []

    for i in range(len(bboxes)):
        boxA = bboxes[i]
        scoreA = scores[i]

        box_added = False

        for j in range(i+1, len(bboxes)):
            boxB = bboxes[j]
            scoreB = scores[j]

            contains = -1
            # if boxA is contained inside boxB
            if boxA[0] &gt; boxB[0] and boxA[1] &gt; boxB[1] and boxA[2] &lt; boxB[2] and boxA[3] &lt; boxB[3]:
                contains = 0
            # if boxB is contained inside boxA
            elif boxA[0] &lt; boxB[0] and boxA[1] &lt; boxB[1] and boxA[2] &gt; boxB[2] and boxA[3] &gt; boxB[3]:
                contains = 1

            if contains != -1:
                if mode == &#34;highest&#34;:
                    # keep only the one with the biggest score
                    if scoreA &gt; scoreB:
                        if not added[i]:
                            new_bboxes.append(boxA)
                            new_class_ids.append(class_ids[i])
                            new_scores.append(scores[i])
                            added[i] = True
                            added[j] = True
                            box_added = True
                    else:
                        if not added[j]:
                            new_bboxes.append(boxB)
                            new_class_ids.append(class_ids[j])
                            new_scores.append(scores[j])
                            added[i] = True
                            added[j] = True
                            box_added = True
                elif mode == &#34;biggest&#34;:
                    if contains == 0:
                        if not added[j]:
                            new_bboxes.append(boxB)
                            new_class_ids.append(class_ids[j])
                            new_scores.append(scores[j])
                            added[j] = True
                            added[i] = True
                            box_added = True
                    elif contains == 1:
                        if not added[i]:
                            new_bboxes.append(boxA)
                            new_class_ids.append(class_ids[i])
                            new_scores.append(scores[i])
                            added[i] = True
                            added[j] = True
                            box_added = True

        # if not found overlapping bboxes, add it
        if not box_added and not added[i]:
            new_bboxes.append(boxA)
            new_class_ids.append(class_ids[i])
            new_scores.append(scores[i])
            added[i] = True

    return new_bboxes, new_class_ids, new_scores</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.training" href="index.html">helipad_detection.src.training</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helipad_detection.src.training.filter_manager.FilterManager" href="#helipad_detection.src.training.filter_manager.FilterManager">FilterManager</a></code></h4>
<ul class="">
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.bb_intersection_over_union" href="#helipad_detection.src.training.filter_manager.FilterManager.bb_intersection_over_union">bb_intersection_over_union</a></code></li>
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.compute_area" href="#helipad_detection.src.training.filter_manager.FilterManager.compute_area">compute_area</a></code></li>
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.compute_interArea" href="#helipad_detection.src.training.filter_manager.FilterManager.compute_interArea">compute_interArea</a></code></li>
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.filter_by_iou" href="#helipad_detection.src.training.filter_manager.FilterManager.filter_by_iou">filter_by_iou</a></code></li>
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.filter_by_scores" href="#helipad_detection.src.training.filter_manager.FilterManager.filter_by_scores">filter_by_scores</a></code></li>
<li><code><a title="helipad_detection.src.training.filter_manager.FilterManager.filter_contains" href="#helipad_detection.src.training.filter_manager.FilterManager.filter_contains">filter_contains</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>