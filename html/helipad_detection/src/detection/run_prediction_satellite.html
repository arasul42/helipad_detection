<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.detection.run_prediction_satellite API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.detection.run_prediction_satellite</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import cv2
import json
from numpy import expand_dims
from tqdm import tqdm

from mrcnn.model import MaskRCNN
from mrcnn.model import mold_image

import sys
sys.path.append(&#39;../&#39;)

from helipad_detection.src.utils.globalmaptiles import GlobalMercator

from helipad_detection.src.training.helipad_config import HelipadConfig
from helipad_detection.src.training.filter_manager import FilterManager

os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;
os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;1&#34;


class RunPredictionSatellite:
    
    &#34;&#34;&#34;
    Run the detection on Satellite images saved with the TMS file structure using a certain model.
    &#34;&#34;&#34;
    
    def __init__(self, cache_tms_sat_folder, output_meta_folder, zoom_level,
                 model_folder, weights_filename, model_number, activate_filters=False,
                 redo_prediction=False):
        
        &#34;&#34;&#34;
        `cache_tms_sat_folder`: string, path to the image folder\n 
        `output_meta_folder`:string, path to the folder where to store the meta files\n
        `zoom_level`: int, only TMS images having a zoom equal to `zoom_level` are loaded\n
        `model_folder`:string, path to the folder where the models weights are saved\n
        `weights_filename`: string, file name of the model weights\n
        `model_number`: int, number of the model\n
        `activate_filters`: boolean, True to activate the bounding boxes filters\n
        `redo_prediction`: boolean, True to re-run the prediction on images that were already predicted by model `model_number`\n
        &#34;&#34;&#34;
        
        self.cache_tms_sat_folder = cache_tms_sat_folder
        self.output_meta_folder = output_meta_folder
        self.zoom_level = zoom_level
        self.model_folder = model_folder
        self.weights_filename = weights_filename
        self.model_number = model_number
        self.activate_filters = activate_filters
        self.redo_prediction = redo_prediction
        self.image_folder = os.path.join(self.cache_tms_sat_folder, str(zoom_level))
        self.meta_folder = os.path.join(self.output_meta_folder, str(zoom_level))
        if not os.path.isdir(os.path.join(self.output_meta_folder, str(zoom_level))):
            os.mkdir(os.path.join(self.output_meta_folder, str(zoom_level)))
        self.target_files = self.build_target_files_path()
        self.config = HelipadConfig()
        self.globalmercator = GlobalMercator()
        self.model_predict_setup()

    def build_target_files_path(self):
        &#34;&#34;&#34;
        Build a list of tuple `(filepath, meta_filepath)` of the files to run the detection 
        &#34;&#34;&#34;
        target_files = []
        for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
            for file in files:
                xtile = os.path.basename(subdir)
                ytile = os.path.splitext(file)[0]
                filepath = os.path.join(subdir, file)
                meta_filepath = os.path.join(self.output_meta_folder,
                                             str(self.zoom_level),
                                             str(xtile),
                                             &#39;Satellite_{}_{}_{}.meta&#39;.format(str(self.zoom_level), str(xtile), str(ytile)))
                target_files.append([filepath, meta_filepath])
        return target_files

    def model_predict_setup(self):
        &#34;&#34;&#34;
        Setup the model
        &#34;&#34;&#34;
        self.model_predict = MaskRCNN(mode=&#39;inference&#39;, model_dir=self.model_folder, config=self.config)
        self.model_predict.load_weights(os.path.join(self.model_folder, self.weights_filename),
                                        by_name=True)

    def get_coordinates_info(self, xtile, ytile, zoom_level):
        &#34;&#34;&#34;
        Convert TMS coordinates to GPS coordinates
        `xtile`: XTile in the TMS coordinates\n
        `ytile`: YTile in the TMS coordinates\n
        `zoom_level`: Zoom level in the TMS coordinates\n
        Returns \n
        `coordinates_info`: dict, dictionnary containing the latitude, longitudes, and bounds of the images.
        &#34;&#34;&#34;
        coordinates_info = dict()
        coordinates_info[&#34;zoom&#34;] = zoom_level
        coordinates_info[&#34;xtile&#34;] = xtile
        coordinates_info[&#34;ytile&#34;] = ytile

        tile_bounds_coordinates = self.globalmercator.TileLatLonBox(xtile, ytile, zoom_level)
        tile_center_lat = (tile_bounds_coordinates[0][0] + tile_bounds_coordinates[3][0]) / 2
        tile_center_lon = (tile_bounds_coordinates[0][1] + tile_bounds_coordinates[3][1]) / 2
        coordinates_info[&#34;latitude&#34;] = tile_center_lat
        coordinates_info[&#34;longitude&#34;] = tile_center_lon
        coordinates_info[&#34;bounds&#34;] = tile_bounds_coordinates

        return coordinates_info

    def predict_image(self, image):
        &#34;&#34;&#34;
        Predict the `image`\n
        Returns \n
        `prediction`: a dictionnary containing the bounding boxes, class_ids and the confidence scores.
        &#34;&#34;&#34;
        scaled_image = mold_image(image, self.config)
        sample = expand_dims(scaled_image, 0)
        yhat = self.model_predict.detect(sample, verbose=0)

        rois = yhat[0][&#39;rois&#39;]
        class_id = yhat[0][&#39;class_ids&#39;]
        score = yhat[0][&#39;scores&#39;]

        # reorder rois :
        # x1, y1, x2, y2
        bboxes = []
        for roi in rois:
            box = [int(roi[1]), int(roi[0]), int(roi[3]), int(roi[2])]
            bboxes.append(box)

        class_ids = []
        for id in class_id:
            class_ids.append(int(id))

        scores = []
        for s in score:
            scores.append(float(s))

        # filter is helipad detected
        if self.activate_filters and len(scores) &gt; 0:
            # remove if score &lt; threshold (see FilterManager for default values)
            bboxes, class_ids, scores = FilterManager.filter_by_scores(bboxes, class_ids, scores)
            # Filter overlapping box (see FilterManager for default value of threshold_iou and threshold_area)
            bboxes, class_ids, scores = FilterManager.filter_by_iou(bboxes, class_ids, scores)

        # Save to meta roi
        prediction = dict()
        prediction[&#34;box&#34;] = bboxes
        prediction[&#34;class_id&#34;] = class_ids
        prediction[&#34;score&#34;] = scores

        if len(bboxes) &gt; 0:
            prediction[&#34;helipad&#34;] = True
            print(scores)
        else:
            prediction[&#34;helipad&#34;] = False

        return prediction

    def convert_point_to_coordinate(self, x, y, minLat, minLon, maxLat, maxLon, image_shape, verbose=0):
        &#34;&#34;&#34;
        Get the corresponding GPS coordinates of a pixel inside an image\n
        `x`: int, pixel x point\n
        `y`: int, pixel y point\n
        `minLat`: float, minimum latitude of the image\n
        `minLon`: float, minimum longitude of the image\n
        `maxLat`: float, maximum latitude of the image\n
        `maxLon`: float, maximum longitude of the image\n
        `image_shape`: tuple, shape of the image\n
        `verbose`: int, 1 to print the latitude and longitude\n
        Returns\n
        `lat`: float, the latitude of the point\n
        `lon`: float, the longitude of the point\n
        &#34;&#34;&#34;
        tmp = x
        x = y
        y = tmp
        lat_factor = (image_shape[0] - x)/image_shape[0]
        lon_factor = y / image_shape[1]
        lat = minLat + (abs(minLat - maxLat) * lat_factor)
        lon = minLon + (abs(minLon - maxLon) * lon_factor)

        if verbose == 1:
            print(lat)
            print(lon)

        return lat, lon

    def convert_bboxes_to_coordinates(self, bboxes, bounds_coordinates, image_shape):
        &#34;&#34;&#34;
        Convert detected bounding boxes to GPS coordinates
        `bboxes`: a list of bounding boxes\n
        `bounds_coordinates`: a list containing the GPS coordinates of the four corners of the image\n
        `image_shape`: a tuple, the shape of the image\n
        Returns\n
        `bboxes_center_coordinates`: a list of tuple (latitude, longitude) of the center of each bounding boxes\n
        `bboxes_bounds_coordinates`: a list of four tuples (latitude, longitude) having the GPS coordinates of the four corners of the bounding boxes\n
        &#34;&#34;&#34;

        minLat, minLon = bounds_coordinates[0][0], bounds_coordinates[0][1]
        maxLat, maxLon = bounds_coordinates[3][0], bounds_coordinates[3][1]

        # lat lon of center
        center_pixel = []
        for box in bboxes:
            xmean = (box[0] + box[2]) / 2
            ymean = (box[1] + box[3]) / 2
            center_pixel.append((xmean, ymean))

        bboxes_center_coordinates = []
        for center in center_pixel:
            xmean, ymean = center[0], center[1]
            bboxes_center_lat, bboxes_center_lon = self.convert_point_to_coordinate(xmean, ymean,
                                                                                    minLat, minLon,
                                                                                    maxLat, maxLon,
                                                                                    image_shape,
                                                                                    verbose=1)
            bboxes_center_coordinates.append((bboxes_center_lat, bboxes_center_lon))

        bboxes_bounds_coordinates = []
        for box in bboxes:
            corners = [(box[0], box[1]),  # minx, miny
                       (box[0], box[3]),  # minx, maxy
                       (box[2], box[1]),  # maxx, miny
                       (box[2], box[3])]  # maxx, maxy
            corners_coordinates = []
            for point in corners:
                x, y = point[0], point[1]
                lat, lon = self.convert_point_to_coordinate(x, y, minLat, minLon, maxLat, maxLon, image_shape)
                point_coordinates = (lat, lon)
                corners_coordinates.append(point_coordinates)
            bboxes_bounds_coordinates.append(corners_coordinates)

        return bboxes_center_coordinates, bboxes_bounds_coordinates
    
    def initiate_meta(self, meta_filename):
        &#34;&#34;&#34;
        Initiate the meta file from the `meta_filename`\n
        Returns a dictionnary `meta` with a key `coordinates` saving the location information of the image
        &#34;&#34;&#34;
        meta = dict()
        meta_coordinates = meta_filename.split(&#39;_&#39;)
        zoom_level = int(meta_coordinates[1])
        xtile = int(meta_coordinates[2])
        ytile = int(meta_coordinates[3])
        coordinates_info = self.get_coordinates_info(xtile, ytile, zoom_level)
        meta[&#34;coordinates&#34;] = coordinates_info
        return meta

    
    def run(self):
        &#34;&#34;&#34;
        Run the Prediction
        &#34;&#34;&#34;
        for i in tqdm(range(len(self.target_files))):
            target_file = self.target_files[i]

            image_path = target_file[0]
            meta_path = target_file[1]
            meta_filename = os.path.splitext(os.path.basename(meta_path))[0]
            image = cv2.imread(image_path)
            image_shape = image.shape

            if os.path.isfile(meta_path):
                try:
                    with open(meta_path, &#39;r&#39;) as f:
                        meta = json.load(f)
                except:
                    meta = self.initiate_meta(meta_filename)
            else:
                meta = self.initiate_meta(meta_filename)
            
            coordinates_info = meta[&#34;coordinates&#34;]
            xtile = coordinates_info[&#34;xtile&#34;]
            
            if &#34;predicted&#34; in meta:
                predicted = meta[&#34;predicted&#34;]
            else:
                predicted = {}

            key = &#34;model_{}&#34;.format(self.model_number)
            
            if key in predicted and not self.redo_prediction:
                continue
            
            # now predict on image
            prediction = self.predict_image(image)

            bounds_coordinate = coordinates_info[&#34;bounds&#34;]
            bboxes = prediction[&#34;box&#34;]

            bboxes_center_coordinates, bboxes_bounds_coordinates = self.convert_bboxes_to_coordinates(bboxes,
                                                                                                      bounds_coordinate,
                                                                                                      image_shape)

            prediction_coordinates = dict()
            prediction_coordinates[&#34;center&#34;] = bboxes_center_coordinates
            prediction_coordinates[&#34;bounds&#34;] = bboxes_bounds_coordinates
            prediction[&#34;coordinates&#34;] = prediction_coordinates

            predicted[key] = prediction

            meta[&#34;predicted&#34;] = predicted
            
            if not os.path.isdir(os.path.join(self.output_meta_folder,
                                              str(self.zoom_level))):
                os.mkdir(os.path.join(self.output_meta_folder,
                                      str(self.zoom_level)))
            if not os.path.isdir(os.path.join(self.output_meta_folder,
                                              str(self.zoom_level),
                                              str(xtile))):
                os.mkdir(os.path.join(self.output_meta_folder,
                                      str(self.zoom_level),
                                      str(xtile)))

            with open(meta_path, &#39;w&#39;) as f:
                json.dump(meta, f, indent=4, sort_keys=True)


if __name__ == &#34;__main__&#34;:

    # cache_tms_sat_folder = &#34;C:\\Users\\jonas\\Desktop\\SAS.Planet.Release.191221\\\cache_tms\\sat&#34;
    # cache_tms_sat_folder = &#34;C:\\Users\\jonas\\Desktop\\cache_tms_test&#34;
    # output_meta_folder = &#34;C:\\Users\\jonas\\Desktop\\cache_tms_meta&#34;
    # model_folder = &#34;C:\\Users\\jonas\\Desktop\\Helipad\\model&#34;

    cache_tms_sat_folder = &#34;../../../Detection/Detection_Dataset&#34;
    output_meta_folder = &#34;../../../Detection/Detection_Dataset_meta&#34;
    model_folder = &#34;../../model&#34;

    # weights_filename = &#34;helipad_cfg_6_aug4_3+20200103T1225/mask_rcnn_helipad_cfg_6_aug4_3+_0288.h5&#34;
    # model_number = 5

    # weights_filename = &#34;helipad_cfg_8_no47_aug2_3+20200108T0600/mask_rcnn_helipad_cfg_8_no47_aug2_3+_0472.h5&#34;
    # model_number = 7

    # weights_filename = &#34;helipad_cfg_9_no47_aug2_3+20200112T2326/mask_rcnn_helipad_cfg_9_no47_aug2_3+_0257.h5&#34;
    # model_number = 8

    weights_filename = &#34;helipad_cfg_aug2_5+20191211T1749/mask_rcnn_helipad_cfg_aug2_5+_0381.h5&#34;
    model_number = 4

    zoom_level = [18, 19]
    activate_filters = False

    for zoom in zoom_level:

        run_prediction_satellite = RunPredictionSatellite(cache_tms_sat_folder=cache_tms_sat_folder,
                                                          output_meta_folder=output_meta_folder,
                                                          zoom_level=zoom,
                                                          model_folder=model_folder,
                                                          weights_filename=weights_filename,
                                                          model_number=model_number,
                                                          activate_filters=activate_filters)

        run_prediction_satellite.run()

    #TODO:
    # load the image
    # write image coordinates (zoom level, tsm coordinates, center coordinates and corner coordinates)
    # load the model
    # predict
    # save prediction in meta
    # get the center of box
    # convert center to coordinates
    # save center coordinates
    # OPTIONAL : include the google maps url of the helipad
    # OPTIONAL : include info of location (country, city, id? ...)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite"><code class="flex name class">
<span>class <span class="ident">RunPredictionSatellite</span></span>
<span>(</span><span>cache_tms_sat_folder, output_meta_folder, zoom_level, model_folder, weights_filename, model_number, activate_filters=False, redo_prediction=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the detection on Satellite images saved with the TMS file structure using a certain model.</p>
<p><code>cache_tms_sat_folder</code>: string, path to the image folder</p>
<p><code>output_meta_folder</code>:string, path to the folder where to store the meta files</p>
<p><code>zoom_level</code>: int, only TMS images having a zoom equal to <code>zoom_level</code> are loaded</p>
<p><code>model_folder</code>:string, path to the folder where the models weights are saved</p>
<p><code>weights_filename</code>: string, file name of the model weights</p>
<p><code>model_number</code>: int, number of the model</p>
<p><code>activate_filters</code>: boolean, True to activate the bounding boxes filters</p>
<p><code>redo_prediction</code>: boolean, True to re-run the prediction on images that were already predicted by model <code>model_number</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunPredictionSatellite:
    
    &#34;&#34;&#34;
    Run the detection on Satellite images saved with the TMS file structure using a certain model.
    &#34;&#34;&#34;
    
    def __init__(self, cache_tms_sat_folder, output_meta_folder, zoom_level,
                 model_folder, weights_filename, model_number, activate_filters=False,
                 redo_prediction=False):
        
        &#34;&#34;&#34;
        `cache_tms_sat_folder`: string, path to the image folder\n 
        `output_meta_folder`:string, path to the folder where to store the meta files\n
        `zoom_level`: int, only TMS images having a zoom equal to `zoom_level` are loaded\n
        `model_folder`:string, path to the folder where the models weights are saved\n
        `weights_filename`: string, file name of the model weights\n
        `model_number`: int, number of the model\n
        `activate_filters`: boolean, True to activate the bounding boxes filters\n
        `redo_prediction`: boolean, True to re-run the prediction on images that were already predicted by model `model_number`\n
        &#34;&#34;&#34;
        
        self.cache_tms_sat_folder = cache_tms_sat_folder
        self.output_meta_folder = output_meta_folder
        self.zoom_level = zoom_level
        self.model_folder = model_folder
        self.weights_filename = weights_filename
        self.model_number = model_number
        self.activate_filters = activate_filters
        self.redo_prediction = redo_prediction
        self.image_folder = os.path.join(self.cache_tms_sat_folder, str(zoom_level))
        self.meta_folder = os.path.join(self.output_meta_folder, str(zoom_level))
        if not os.path.isdir(os.path.join(self.output_meta_folder, str(zoom_level))):
            os.mkdir(os.path.join(self.output_meta_folder, str(zoom_level)))
        self.target_files = self.build_target_files_path()
        self.config = HelipadConfig()
        self.globalmercator = GlobalMercator()
        self.model_predict_setup()

    def build_target_files_path(self):
        &#34;&#34;&#34;
        Build a list of tuple `(filepath, meta_filepath)` of the files to run the detection 
        &#34;&#34;&#34;
        target_files = []
        for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
            for file in files:
                xtile = os.path.basename(subdir)
                ytile = os.path.splitext(file)[0]
                filepath = os.path.join(subdir, file)
                meta_filepath = os.path.join(self.output_meta_folder,
                                             str(self.zoom_level),
                                             str(xtile),
                                             &#39;Satellite_{}_{}_{}.meta&#39;.format(str(self.zoom_level), str(xtile), str(ytile)))
                target_files.append([filepath, meta_filepath])
        return target_files

    def model_predict_setup(self):
        &#34;&#34;&#34;
        Setup the model
        &#34;&#34;&#34;
        self.model_predict = MaskRCNN(mode=&#39;inference&#39;, model_dir=self.model_folder, config=self.config)
        self.model_predict.load_weights(os.path.join(self.model_folder, self.weights_filename),
                                        by_name=True)

    def get_coordinates_info(self, xtile, ytile, zoom_level):
        &#34;&#34;&#34;
        Convert TMS coordinates to GPS coordinates
        `xtile`: XTile in the TMS coordinates\n
        `ytile`: YTile in the TMS coordinates\n
        `zoom_level`: Zoom level in the TMS coordinates\n
        Returns \n
        `coordinates_info`: dict, dictionnary containing the latitude, longitudes, and bounds of the images.
        &#34;&#34;&#34;
        coordinates_info = dict()
        coordinates_info[&#34;zoom&#34;] = zoom_level
        coordinates_info[&#34;xtile&#34;] = xtile
        coordinates_info[&#34;ytile&#34;] = ytile

        tile_bounds_coordinates = self.globalmercator.TileLatLonBox(xtile, ytile, zoom_level)
        tile_center_lat = (tile_bounds_coordinates[0][0] + tile_bounds_coordinates[3][0]) / 2
        tile_center_lon = (tile_bounds_coordinates[0][1] + tile_bounds_coordinates[3][1]) / 2
        coordinates_info[&#34;latitude&#34;] = tile_center_lat
        coordinates_info[&#34;longitude&#34;] = tile_center_lon
        coordinates_info[&#34;bounds&#34;] = tile_bounds_coordinates

        return coordinates_info

    def predict_image(self, image):
        &#34;&#34;&#34;
        Predict the `image`\n
        Returns \n
        `prediction`: a dictionnary containing the bounding boxes, class_ids and the confidence scores.
        &#34;&#34;&#34;
        scaled_image = mold_image(image, self.config)
        sample = expand_dims(scaled_image, 0)
        yhat = self.model_predict.detect(sample, verbose=0)

        rois = yhat[0][&#39;rois&#39;]
        class_id = yhat[0][&#39;class_ids&#39;]
        score = yhat[0][&#39;scores&#39;]

        # reorder rois :
        # x1, y1, x2, y2
        bboxes = []
        for roi in rois:
            box = [int(roi[1]), int(roi[0]), int(roi[3]), int(roi[2])]
            bboxes.append(box)

        class_ids = []
        for id in class_id:
            class_ids.append(int(id))

        scores = []
        for s in score:
            scores.append(float(s))

        # filter is helipad detected
        if self.activate_filters and len(scores) &gt; 0:
            # remove if score &lt; threshold (see FilterManager for default values)
            bboxes, class_ids, scores = FilterManager.filter_by_scores(bboxes, class_ids, scores)
            # Filter overlapping box (see FilterManager for default value of threshold_iou and threshold_area)
            bboxes, class_ids, scores = FilterManager.filter_by_iou(bboxes, class_ids, scores)

        # Save to meta roi
        prediction = dict()
        prediction[&#34;box&#34;] = bboxes
        prediction[&#34;class_id&#34;] = class_ids
        prediction[&#34;score&#34;] = scores

        if len(bboxes) &gt; 0:
            prediction[&#34;helipad&#34;] = True
            print(scores)
        else:
            prediction[&#34;helipad&#34;] = False

        return prediction

    def convert_point_to_coordinate(self, x, y, minLat, minLon, maxLat, maxLon, image_shape, verbose=0):
        &#34;&#34;&#34;
        Get the corresponding GPS coordinates of a pixel inside an image\n
        `x`: int, pixel x point\n
        `y`: int, pixel y point\n
        `minLat`: float, minimum latitude of the image\n
        `minLon`: float, minimum longitude of the image\n
        `maxLat`: float, maximum latitude of the image\n
        `maxLon`: float, maximum longitude of the image\n
        `image_shape`: tuple, shape of the image\n
        `verbose`: int, 1 to print the latitude and longitude\n
        Returns\n
        `lat`: float, the latitude of the point\n
        `lon`: float, the longitude of the point\n
        &#34;&#34;&#34;
        tmp = x
        x = y
        y = tmp
        lat_factor = (image_shape[0] - x)/image_shape[0]
        lon_factor = y / image_shape[1]
        lat = minLat + (abs(minLat - maxLat) * lat_factor)
        lon = minLon + (abs(minLon - maxLon) * lon_factor)

        if verbose == 1:
            print(lat)
            print(lon)

        return lat, lon

    def convert_bboxes_to_coordinates(self, bboxes, bounds_coordinates, image_shape):
        &#34;&#34;&#34;
        Convert detected bounding boxes to GPS coordinates
        `bboxes`: a list of bounding boxes\n
        `bounds_coordinates`: a list containing the GPS coordinates of the four corners of the image\n
        `image_shape`: a tuple, the shape of the image\n
        Returns\n
        `bboxes_center_coordinates`: a list of tuple (latitude, longitude) of the center of each bounding boxes\n
        `bboxes_bounds_coordinates`: a list of four tuples (latitude, longitude) having the GPS coordinates of the four corners of the bounding boxes\n
        &#34;&#34;&#34;

        minLat, minLon = bounds_coordinates[0][0], bounds_coordinates[0][1]
        maxLat, maxLon = bounds_coordinates[3][0], bounds_coordinates[3][1]

        # lat lon of center
        center_pixel = []
        for box in bboxes:
            xmean = (box[0] + box[2]) / 2
            ymean = (box[1] + box[3]) / 2
            center_pixel.append((xmean, ymean))

        bboxes_center_coordinates = []
        for center in center_pixel:
            xmean, ymean = center[0], center[1]
            bboxes_center_lat, bboxes_center_lon = self.convert_point_to_coordinate(xmean, ymean,
                                                                                    minLat, minLon,
                                                                                    maxLat, maxLon,
                                                                                    image_shape,
                                                                                    verbose=1)
            bboxes_center_coordinates.append((bboxes_center_lat, bboxes_center_lon))

        bboxes_bounds_coordinates = []
        for box in bboxes:
            corners = [(box[0], box[1]),  # minx, miny
                       (box[0], box[3]),  # minx, maxy
                       (box[2], box[1]),  # maxx, miny
                       (box[2], box[3])]  # maxx, maxy
            corners_coordinates = []
            for point in corners:
                x, y = point[0], point[1]
                lat, lon = self.convert_point_to_coordinate(x, y, minLat, minLon, maxLat, maxLon, image_shape)
                point_coordinates = (lat, lon)
                corners_coordinates.append(point_coordinates)
            bboxes_bounds_coordinates.append(corners_coordinates)

        return bboxes_center_coordinates, bboxes_bounds_coordinates
    
    def initiate_meta(self, meta_filename):
        &#34;&#34;&#34;
        Initiate the meta file from the `meta_filename`\n
        Returns a dictionnary `meta` with a key `coordinates` saving the location information of the image
        &#34;&#34;&#34;
        meta = dict()
        meta_coordinates = meta_filename.split(&#39;_&#39;)
        zoom_level = int(meta_coordinates[1])
        xtile = int(meta_coordinates[2])
        ytile = int(meta_coordinates[3])
        coordinates_info = self.get_coordinates_info(xtile, ytile, zoom_level)
        meta[&#34;coordinates&#34;] = coordinates_info
        return meta

    
    def run(self):
        &#34;&#34;&#34;
        Run the Prediction
        &#34;&#34;&#34;
        for i in tqdm(range(len(self.target_files))):
            target_file = self.target_files[i]

            image_path = target_file[0]
            meta_path = target_file[1]
            meta_filename = os.path.splitext(os.path.basename(meta_path))[0]
            image = cv2.imread(image_path)
            image_shape = image.shape

            if os.path.isfile(meta_path):
                try:
                    with open(meta_path, &#39;r&#39;) as f:
                        meta = json.load(f)
                except:
                    meta = self.initiate_meta(meta_filename)
            else:
                meta = self.initiate_meta(meta_filename)
            
            coordinates_info = meta[&#34;coordinates&#34;]
            xtile = coordinates_info[&#34;xtile&#34;]
            
            if &#34;predicted&#34; in meta:
                predicted = meta[&#34;predicted&#34;]
            else:
                predicted = {}

            key = &#34;model_{}&#34;.format(self.model_number)
            
            if key in predicted and not self.redo_prediction:
                continue
            
            # now predict on image
            prediction = self.predict_image(image)

            bounds_coordinate = coordinates_info[&#34;bounds&#34;]
            bboxes = prediction[&#34;box&#34;]

            bboxes_center_coordinates, bboxes_bounds_coordinates = self.convert_bboxes_to_coordinates(bboxes,
                                                                                                      bounds_coordinate,
                                                                                                      image_shape)

            prediction_coordinates = dict()
            prediction_coordinates[&#34;center&#34;] = bboxes_center_coordinates
            prediction_coordinates[&#34;bounds&#34;] = bboxes_bounds_coordinates
            prediction[&#34;coordinates&#34;] = prediction_coordinates

            predicted[key] = prediction

            meta[&#34;predicted&#34;] = predicted
            
            if not os.path.isdir(os.path.join(self.output_meta_folder,
                                              str(self.zoom_level))):
                os.mkdir(os.path.join(self.output_meta_folder,
                                      str(self.zoom_level)))
            if not os.path.isdir(os.path.join(self.output_meta_folder,
                                              str(self.zoom_level),
                                              str(xtile))):
                os.mkdir(os.path.join(self.output_meta_folder,
                                      str(self.zoom_level),
                                      str(xtile)))

            with open(meta_path, &#39;w&#39;) as f:
                json.dump(meta, f, indent=4, sort_keys=True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.build_target_files_path"><code class="name flex">
<span>def <span class="ident">build_target_files_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a list of tuple <code>(filepath, meta_filepath)</code> of the files to run the detection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_target_files_path(self):
    &#34;&#34;&#34;
    Build a list of tuple `(filepath, meta_filepath)` of the files to run the detection 
    &#34;&#34;&#34;
    target_files = []
    for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
        for file in files:
            xtile = os.path.basename(subdir)
            ytile = os.path.splitext(file)[0]
            filepath = os.path.join(subdir, file)
            meta_filepath = os.path.join(self.output_meta_folder,
                                         str(self.zoom_level),
                                         str(xtile),
                                         &#39;Satellite_{}_{}_{}.meta&#39;.format(str(self.zoom_level), str(xtile), str(ytile)))
            target_files.append([filepath, meta_filepath])
    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_bboxes_to_coordinates"><code class="name flex">
<span>def <span class="ident">convert_bboxes_to_coordinates</span></span>(<span>self, bboxes, bounds_coordinates, image_shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert detected bounding boxes to GPS coordinates
<code>bboxes</code>: a list of bounding boxes</p>
<p><code>bounds_coordinates</code>: a list containing the GPS coordinates of the four corners of the image</p>
<p><code>image_shape</code>: a tuple, the shape of the image</p>
<p>Returns</p>
<p><code>bboxes_center_coordinates</code>: a list of tuple (latitude, longitude) of the center of each bounding boxes</p>
<p><code>bboxes_bounds_coordinates</code>: a list of four tuples (latitude, longitude) having the GPS coordinates of the four corners of the bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bboxes_to_coordinates(self, bboxes, bounds_coordinates, image_shape):
    &#34;&#34;&#34;
    Convert detected bounding boxes to GPS coordinates
    `bboxes`: a list of bounding boxes\n
    `bounds_coordinates`: a list containing the GPS coordinates of the four corners of the image\n
    `image_shape`: a tuple, the shape of the image\n
    Returns\n
    `bboxes_center_coordinates`: a list of tuple (latitude, longitude) of the center of each bounding boxes\n
    `bboxes_bounds_coordinates`: a list of four tuples (latitude, longitude) having the GPS coordinates of the four corners of the bounding boxes\n
    &#34;&#34;&#34;

    minLat, minLon = bounds_coordinates[0][0], bounds_coordinates[0][1]
    maxLat, maxLon = bounds_coordinates[3][0], bounds_coordinates[3][1]

    # lat lon of center
    center_pixel = []
    for box in bboxes:
        xmean = (box[0] + box[2]) / 2
        ymean = (box[1] + box[3]) / 2
        center_pixel.append((xmean, ymean))

    bboxes_center_coordinates = []
    for center in center_pixel:
        xmean, ymean = center[0], center[1]
        bboxes_center_lat, bboxes_center_lon = self.convert_point_to_coordinate(xmean, ymean,
                                                                                minLat, minLon,
                                                                                maxLat, maxLon,
                                                                                image_shape,
                                                                                verbose=1)
        bboxes_center_coordinates.append((bboxes_center_lat, bboxes_center_lon))

    bboxes_bounds_coordinates = []
    for box in bboxes:
        corners = [(box[0], box[1]),  # minx, miny
                   (box[0], box[3]),  # minx, maxy
                   (box[2], box[1]),  # maxx, miny
                   (box[2], box[3])]  # maxx, maxy
        corners_coordinates = []
        for point in corners:
            x, y = point[0], point[1]
            lat, lon = self.convert_point_to_coordinate(x, y, minLat, minLon, maxLat, maxLon, image_shape)
            point_coordinates = (lat, lon)
            corners_coordinates.append(point_coordinates)
        bboxes_bounds_coordinates.append(corners_coordinates)

    return bboxes_center_coordinates, bboxes_bounds_coordinates</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_point_to_coordinate"><code class="name flex">
<span>def <span class="ident">convert_point_to_coordinate</span></span>(<span>self, x, y, minLat, minLon, maxLat, maxLon, image_shape, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the corresponding GPS coordinates of a pixel inside an image</p>
<p><code>x</code>: int, pixel x point</p>
<p><code>y</code>: int, pixel y point</p>
<p><code>minLat</code>: float, minimum latitude of the image</p>
<p><code>minLon</code>: float, minimum longitude of the image</p>
<p><code>maxLat</code>: float, maximum latitude of the image</p>
<p><code>maxLon</code>: float, maximum longitude of the image</p>
<p><code>image_shape</code>: tuple, shape of the image</p>
<p><code>verbose</code>: int, 1 to print the latitude and longitude</p>
<p>Returns</p>
<p><code>lat</code>: float, the latitude of the point</p>
<p><code>lon</code>: float, the longitude of the point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_point_to_coordinate(self, x, y, minLat, minLon, maxLat, maxLon, image_shape, verbose=0):
    &#34;&#34;&#34;
    Get the corresponding GPS coordinates of a pixel inside an image\n
    `x`: int, pixel x point\n
    `y`: int, pixel y point\n
    `minLat`: float, minimum latitude of the image\n
    `minLon`: float, minimum longitude of the image\n
    `maxLat`: float, maximum latitude of the image\n
    `maxLon`: float, maximum longitude of the image\n
    `image_shape`: tuple, shape of the image\n
    `verbose`: int, 1 to print the latitude and longitude\n
    Returns\n
    `lat`: float, the latitude of the point\n
    `lon`: float, the longitude of the point\n
    &#34;&#34;&#34;
    tmp = x
    x = y
    y = tmp
    lat_factor = (image_shape[0] - x)/image_shape[0]
    lon_factor = y / image_shape[1]
    lat = minLat + (abs(minLat - maxLat) * lat_factor)
    lon = minLon + (abs(minLon - maxLon) * lon_factor)

    if verbose == 1:
        print(lat)
        print(lon)

    return lat, lon</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.get_coordinates_info"><code class="name flex">
<span>def <span class="ident">get_coordinates_info</span></span>(<span>self, xtile, ytile, zoom_level)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert TMS coordinates to GPS coordinates
<code>xtile</code>: XTile in the TMS coordinates</p>
<p><code>ytile</code>: YTile in the TMS coordinates</p>
<p><code>zoom_level</code>: Zoom level in the TMS coordinates</p>
<p>Returns </p>
<p><code>coordinates_info</code>: dict, dictionnary containing the latitude, longitudes, and bounds of the images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinates_info(self, xtile, ytile, zoom_level):
    &#34;&#34;&#34;
    Convert TMS coordinates to GPS coordinates
    `xtile`: XTile in the TMS coordinates\n
    `ytile`: YTile in the TMS coordinates\n
    `zoom_level`: Zoom level in the TMS coordinates\n
    Returns \n
    `coordinates_info`: dict, dictionnary containing the latitude, longitudes, and bounds of the images.
    &#34;&#34;&#34;
    coordinates_info = dict()
    coordinates_info[&#34;zoom&#34;] = zoom_level
    coordinates_info[&#34;xtile&#34;] = xtile
    coordinates_info[&#34;ytile&#34;] = ytile

    tile_bounds_coordinates = self.globalmercator.TileLatLonBox(xtile, ytile, zoom_level)
    tile_center_lat = (tile_bounds_coordinates[0][0] + tile_bounds_coordinates[3][0]) / 2
    tile_center_lon = (tile_bounds_coordinates[0][1] + tile_bounds_coordinates[3][1]) / 2
    coordinates_info[&#34;latitude&#34;] = tile_center_lat
    coordinates_info[&#34;longitude&#34;] = tile_center_lon
    coordinates_info[&#34;bounds&#34;] = tile_bounds_coordinates

    return coordinates_info</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.initiate_meta"><code class="name flex">
<span>def <span class="ident">initiate_meta</span></span>(<span>self, meta_filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate the meta file from the <code>meta_filename</code></p>
<p>Returns a dictionnary <code>meta</code> with a key <code>coordinates</code> saving the location information of the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initiate_meta(self, meta_filename):
    &#34;&#34;&#34;
    Initiate the meta file from the `meta_filename`\n
    Returns a dictionnary `meta` with a key `coordinates` saving the location information of the image
    &#34;&#34;&#34;
    meta = dict()
    meta_coordinates = meta_filename.split(&#39;_&#39;)
    zoom_level = int(meta_coordinates[1])
    xtile = int(meta_coordinates[2])
    ytile = int(meta_coordinates[3])
    coordinates_info = self.get_coordinates_info(xtile, ytile, zoom_level)
    meta[&#34;coordinates&#34;] = coordinates_info
    return meta</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.model_predict_setup"><code class="name flex">
<span>def <span class="ident">model_predict_setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup the model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_predict_setup(self):
    &#34;&#34;&#34;
    Setup the model
    &#34;&#34;&#34;
    self.model_predict = MaskRCNN(mode=&#39;inference&#39;, model_dir=self.model_folder, config=self.config)
    self.model_predict.load_weights(os.path.join(self.model_folder, self.weights_filename),
                                    by_name=True)</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.predict_image"><code class="name flex">
<span>def <span class="ident">predict_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the <code>image</code></p>
<p>Returns </p>
<p><code>prediction</code>: a dictionnary containing the bounding boxes, class_ids and the confidence scores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_image(self, image):
    &#34;&#34;&#34;
    Predict the `image`\n
    Returns \n
    `prediction`: a dictionnary containing the bounding boxes, class_ids and the confidence scores.
    &#34;&#34;&#34;
    scaled_image = mold_image(image, self.config)
    sample = expand_dims(scaled_image, 0)
    yhat = self.model_predict.detect(sample, verbose=0)

    rois = yhat[0][&#39;rois&#39;]
    class_id = yhat[0][&#39;class_ids&#39;]
    score = yhat[0][&#39;scores&#39;]

    # reorder rois :
    # x1, y1, x2, y2
    bboxes = []
    for roi in rois:
        box = [int(roi[1]), int(roi[0]), int(roi[3]), int(roi[2])]
        bboxes.append(box)

    class_ids = []
    for id in class_id:
        class_ids.append(int(id))

    scores = []
    for s in score:
        scores.append(float(s))

    # filter is helipad detected
    if self.activate_filters and len(scores) &gt; 0:
        # remove if score &lt; threshold (see FilterManager for default values)
        bboxes, class_ids, scores = FilterManager.filter_by_scores(bboxes, class_ids, scores)
        # Filter overlapping box (see FilterManager for default value of threshold_iou and threshold_area)
        bboxes, class_ids, scores = FilterManager.filter_by_iou(bboxes, class_ids, scores)

    # Save to meta roi
    prediction = dict()
    prediction[&#34;box&#34;] = bboxes
    prediction[&#34;class_id&#34;] = class_ids
    prediction[&#34;score&#34;] = scores

    if len(bboxes) &gt; 0:
        prediction[&#34;helipad&#34;] = True
        print(scores)
    else:
        prediction[&#34;helipad&#34;] = False

    return prediction</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the Prediction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the Prediction
    &#34;&#34;&#34;
    for i in tqdm(range(len(self.target_files))):
        target_file = self.target_files[i]

        image_path = target_file[0]
        meta_path = target_file[1]
        meta_filename = os.path.splitext(os.path.basename(meta_path))[0]
        image = cv2.imread(image_path)
        image_shape = image.shape

        if os.path.isfile(meta_path):
            try:
                with open(meta_path, &#39;r&#39;) as f:
                    meta = json.load(f)
            except:
                meta = self.initiate_meta(meta_filename)
        else:
            meta = self.initiate_meta(meta_filename)
        
        coordinates_info = meta[&#34;coordinates&#34;]
        xtile = coordinates_info[&#34;xtile&#34;]
        
        if &#34;predicted&#34; in meta:
            predicted = meta[&#34;predicted&#34;]
        else:
            predicted = {}

        key = &#34;model_{}&#34;.format(self.model_number)
        
        if key in predicted and not self.redo_prediction:
            continue
        
        # now predict on image
        prediction = self.predict_image(image)

        bounds_coordinate = coordinates_info[&#34;bounds&#34;]
        bboxes = prediction[&#34;box&#34;]

        bboxes_center_coordinates, bboxes_bounds_coordinates = self.convert_bboxes_to_coordinates(bboxes,
                                                                                                  bounds_coordinate,
                                                                                                  image_shape)

        prediction_coordinates = dict()
        prediction_coordinates[&#34;center&#34;] = bboxes_center_coordinates
        prediction_coordinates[&#34;bounds&#34;] = bboxes_bounds_coordinates
        prediction[&#34;coordinates&#34;] = prediction_coordinates

        predicted[key] = prediction

        meta[&#34;predicted&#34;] = predicted
        
        if not os.path.isdir(os.path.join(self.output_meta_folder,
                                          str(self.zoom_level))):
            os.mkdir(os.path.join(self.output_meta_folder,
                                  str(self.zoom_level)))
        if not os.path.isdir(os.path.join(self.output_meta_folder,
                                          str(self.zoom_level),
                                          str(xtile))):
            os.mkdir(os.path.join(self.output_meta_folder,
                                  str(self.zoom_level),
                                  str(xtile)))

        with open(meta_path, &#39;w&#39;) as f:
            json.dump(meta, f, indent=4, sort_keys=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.detection" href="index.html">helipad_detection.src.detection</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite">RunPredictionSatellite</a></code></h4>
<ul class="">
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.build_target_files_path" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.build_target_files_path">build_target_files_path</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_bboxes_to_coordinates" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_bboxes_to_coordinates">convert_bboxes_to_coordinates</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_point_to_coordinate" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.convert_point_to_coordinate">convert_point_to_coordinate</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.get_coordinates_info" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.get_coordinates_info">get_coordinates_info</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.initiate_meta" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.initiate_meta">initiate_meta</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.model_predict_setup" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.model_predict_setup">model_predict_setup</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.predict_image" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.predict_image">predict_image</a></code></li>
<li><code><a title="helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.run" href="#helipad_detection.src.detection.run_prediction_satellite.RunPredictionSatellite.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>