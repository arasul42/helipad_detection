<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.database_management.database_categories_v2 API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.database_management.database_categories_v2</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import matplotlib.pyplot as plt
import cv2
import shutil
import numpy as np
import json


class DatabaseCategoriesv2:

    &#34;&#34;&#34;
    Interface to assign an helipad to a category. The dataset has to be manually annotated first. This second version saves the category directly inside the meta files. The images are not copied. 
    &#34;&#34;&#34;
    def __init__(self, image_folder_original, meta_folder_original, nb_categories=12):
        &#34;&#34;&#34;
        `image_folder_original`: folder containing the original image dataset \n
        `meta_folder_original`: folder containing the original meta files.
        `nb_categories`: the number of categories wanted. 
        &#34;&#34;&#34;
        self.image_folder = image_folder_original
        self.meta_folder = meta_folder_original
        self.nb_categories = nb_categories

        self.files_per_categories = []
        for i in range(nb_categories):
            self.files_per_categories.append([])

        self.target_files = self.build_target_list()
        self.load_last_image_per_category()

    def convert_cat_str_to_int(self, str_cat):
        &#34;&#34;&#34;
        Convert a string into an int. \n
        `str_cat`: the category as string \n
        Returns an int
        &#34;&#34;&#34;
        for i in range(10):
            if str_cat == str(i):
                return i
        if str_cat == &#34;d&#34;:
            return 10
        elif str_cat == &#34;u&#34;:
            return 11

    def build_target_list(self):
        &#34;&#34;&#34;
        Build a list of target files. Each target file is a tuple paths (&#39;imagepath&#39;, &#39;metapath&#39;) to load the files.\n
        Return a list of tuples. 
        &#34;&#34;&#34;
        target_files = []
        for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
            for file in files:
                imagepath = os.path.join(subdir, file)
                metapath = os.path.join(self.meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(metapath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; in meta[&#34;groundtruth&#34;]:
                    str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
                    int_cat = self.convert_cat_str_to_int(str_cat)
                    self.files_per_categories[int_cat].append([imagepath, metapath])
                    continue
                target_files.append([imagepath, metapath])
        return target_files

    def load_last_image_per_category(self):
        &#34;&#34;&#34;
        Load the last image of each category and group them into one image for display.
        &#34;&#34;&#34;
        self.nb_row = 4
        self.nb_col = 3
        self.img_width = 640
        self.img_height = 640
        self.final_img = np.zeros((self.img_width*self.nb_row, self.img_height*self.nb_col, 3))
        i = 0
        j = 0

        for i in range(len(self.files_per_categories)):
            nb_cat = i
            files_cat = self.files_per_categories[nb_cat]
            if len(files_cat) == 0:
                continue
            last_image_meta_path = files_cat[len(files_cat)-1]
            last_image_path = last_image_meta_path[0]
            last_meta_path = last_image_meta_path[1]

            img = cv2.imread(last_image_path)
            img = img/256
            # img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
            # print(img_r.shape)
            i = nb_cat // self.nb_col
            j = nb_cat % self.nb_col

            self.final_img[i * self.img_width:(i+1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img

        self.final_img_r = cv2.resize(self.final_img, (640, 640))

    def add_to_category(self, image_path, meta_path, cat_nb):
        &#34;&#34;&#34;
        Add an `image_path` and `meta_path` to a category `cat_nb`
        &#34;&#34;&#34;
        self.files_per_categories[cat_nb].append([image_path, meta_path])

    def reload_grid_category(self, img, nb_cat):
        &#34;&#34;&#34;
        Reload the grid of the last image per category.\n
        `nb_cat`: the category number\n
        `img`: the image to add to the grid\n
        Display the grid of images
        &#34;&#34;&#34;
        img = img/256
        i = nb_cat // self.nb_col
        j = nb_cat % self.nb_col
        img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
        self.final_img[i * self.img_width:(i + 1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img_r
        self.final_img_r = cv2.resize(self.final_img, (640,640))
        cv2.imshow(&#39;Category&#39;, self.final_img_r)

    def build_categories(self):
        &#34;&#34;&#34;
        Run the interface after initialization.
        &#34;&#34;&#34;
        i = 0

        window_name = &#39;image&#39;

        while i &lt; len(self.target_files):

            image_meta_path = self.target_files[i]
            image_path = image_meta_path[0]
            meta_path = image_meta_path[1]
            print(image_path)

            img = cv2.imread(image_path)
            cv2.imshow(window_name, img)

            cv2.imshow(&#39;Category&#39;, self.final_img_r)

            k = cv2.waitKey(0)

            if k &gt;= 48 and k &lt;= 57:
                target = str(k % 48)
            elif k == 100:
                target = &#39;d&#39;
            elif k == 117:
                target = &#39;u&#39;
            elif k == 8 : #back
                target = -2
            else:
                target = -1

            print(&#34;target = {}&#34;.format(target))

            if target is -1:
                i += 1
                continue
            elif target is -2:
                # delete
                i = i-1
                # find last image path and meta path inside the category
                image_meta_path = self.target_files[i]
                for j in range(self.nb_categories):
                    if image_meta_path in self.files_per_categories[j]:
                        meta_path = image_meta_path[1]
                        # open the meta file and remove the category key
                        with open(meta_path, &#39;r&#39;) as f:
                            meta = json.load(f)
                        groundtruth = meta[&#34;groundtruth&#34;]
                        del groundtruth[&#34;category&#34;]
                        meta[&#34;groundtruth&#34;] = groundtruth
                        with open(meta_path, &#39;w&#39;) as f:
                            json.dump(meta, f, indent=4, sort_keys=True)
                        self.files_per_categories[j].remove(image_meta_path)
                        print(&#34;File removed from category!&#34;)
                        break

                # Redisplay the previous category image inside the grid
                last_cat_img_meta_path = self.files_per_categories[int_cat][len(self.files_per_categories[int_cat])-1]
                image_path = last_cat_img_meta_path[0]
                meta_path = last_cat_img_meta_path[1]
                img = cv2.imread(image_path)
                with open(meta_path, &#39;r&#39;) as f:
                    meta = json.load(f)
                str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
                int_cat = self.convert_cat_str_to_int(str_cat)
                self.reload_grid_category(img, int_cat)
                continue
            else:
                with open(meta_path, &#39;r&#39;) as f:
                    meta = json.load(f)
                meta[&#34;groundtruth&#34;][&#34;category&#34;] = target
                with open(meta_path, &#39;w&#39;) as f:
                    json.dump(meta, f, indent=4, sort_keys=True)
                int_cat = self.convert_cat_str_to_int(target)
                self.files_per_categories[int_cat].append(image_meta_path)

                self.reload_grid_category(img, int_cat)

            i = i + 1

            print(&#34;{} more to go!&#34;.format(len(self.target_files)-i))


if __name__ == &#34;__main__&#34;:

    image_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase&#39;, &#39;Helipad_DataBase_original&#39;)
    meta_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase_meta&#39;, &#39;Helipad_DataBase_meta_original&#39;)

    database_categories = DatabaseCategoriesv2(image_folder, meta_folder, nb_categories=12)

    database_categories.build_categories()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2"><code class="flex name class">
<span>class <span class="ident">DatabaseCategoriesv2</span></span>
<span>(</span><span>image_folder_original, meta_folder_original, nb_categories=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to assign an helipad to a category. The dataset has to be manually annotated first. This second version saves the category directly inside the meta files. The images are not copied. </p>
<p><code>image_folder_original</code>: folder containing the original image dataset </p>
<p><code>meta_folder_original</code>: folder containing the original meta files.
<code>nb_categories</code>: the number of categories wanted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatabaseCategoriesv2:

    &#34;&#34;&#34;
    Interface to assign an helipad to a category. The dataset has to be manually annotated first. This second version saves the category directly inside the meta files. The images are not copied. 
    &#34;&#34;&#34;
    def __init__(self, image_folder_original, meta_folder_original, nb_categories=12):
        &#34;&#34;&#34;
        `image_folder_original`: folder containing the original image dataset \n
        `meta_folder_original`: folder containing the original meta files.
        `nb_categories`: the number of categories wanted. 
        &#34;&#34;&#34;
        self.image_folder = image_folder_original
        self.meta_folder = meta_folder_original
        self.nb_categories = nb_categories

        self.files_per_categories = []
        for i in range(nb_categories):
            self.files_per_categories.append([])

        self.target_files = self.build_target_list()
        self.load_last_image_per_category()

    def convert_cat_str_to_int(self, str_cat):
        &#34;&#34;&#34;
        Convert a string into an int. \n
        `str_cat`: the category as string \n
        Returns an int
        &#34;&#34;&#34;
        for i in range(10):
            if str_cat == str(i):
                return i
        if str_cat == &#34;d&#34;:
            return 10
        elif str_cat == &#34;u&#34;:
            return 11

    def build_target_list(self):
        &#34;&#34;&#34;
        Build a list of target files. Each target file is a tuple paths (&#39;imagepath&#39;, &#39;metapath&#39;) to load the files.\n
        Return a list of tuples. 
        &#34;&#34;&#34;
        target_files = []
        for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
            for file in files:
                imagepath = os.path.join(subdir, file)
                metapath = os.path.join(self.meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(metapath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; in meta[&#34;groundtruth&#34;]:
                    str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
                    int_cat = self.convert_cat_str_to_int(str_cat)
                    self.files_per_categories[int_cat].append([imagepath, metapath])
                    continue
                target_files.append([imagepath, metapath])
        return target_files

    def load_last_image_per_category(self):
        &#34;&#34;&#34;
        Load the last image of each category and group them into one image for display.
        &#34;&#34;&#34;
        self.nb_row = 4
        self.nb_col = 3
        self.img_width = 640
        self.img_height = 640
        self.final_img = np.zeros((self.img_width*self.nb_row, self.img_height*self.nb_col, 3))
        i = 0
        j = 0

        for i in range(len(self.files_per_categories)):
            nb_cat = i
            files_cat = self.files_per_categories[nb_cat]
            if len(files_cat) == 0:
                continue
            last_image_meta_path = files_cat[len(files_cat)-1]
            last_image_path = last_image_meta_path[0]
            last_meta_path = last_image_meta_path[1]

            img = cv2.imread(last_image_path)
            img = img/256
            # img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
            # print(img_r.shape)
            i = nb_cat // self.nb_col
            j = nb_cat % self.nb_col

            self.final_img[i * self.img_width:(i+1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img

        self.final_img_r = cv2.resize(self.final_img, (640, 640))

    def add_to_category(self, image_path, meta_path, cat_nb):
        &#34;&#34;&#34;
        Add an `image_path` and `meta_path` to a category `cat_nb`
        &#34;&#34;&#34;
        self.files_per_categories[cat_nb].append([image_path, meta_path])

    def reload_grid_category(self, img, nb_cat):
        &#34;&#34;&#34;
        Reload the grid of the last image per category.\n
        `nb_cat`: the category number\n
        `img`: the image to add to the grid\n
        Display the grid of images
        &#34;&#34;&#34;
        img = img/256
        i = nb_cat // self.nb_col
        j = nb_cat % self.nb_col
        img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
        self.final_img[i * self.img_width:(i + 1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img_r
        self.final_img_r = cv2.resize(self.final_img, (640,640))
        cv2.imshow(&#39;Category&#39;, self.final_img_r)

    def build_categories(self):
        &#34;&#34;&#34;
        Run the interface after initialization.
        &#34;&#34;&#34;
        i = 0

        window_name = &#39;image&#39;

        while i &lt; len(self.target_files):

            image_meta_path = self.target_files[i]
            image_path = image_meta_path[0]
            meta_path = image_meta_path[1]
            print(image_path)

            img = cv2.imread(image_path)
            cv2.imshow(window_name, img)

            cv2.imshow(&#39;Category&#39;, self.final_img_r)

            k = cv2.waitKey(0)

            if k &gt;= 48 and k &lt;= 57:
                target = str(k % 48)
            elif k == 100:
                target = &#39;d&#39;
            elif k == 117:
                target = &#39;u&#39;
            elif k == 8 : #back
                target = -2
            else:
                target = -1

            print(&#34;target = {}&#34;.format(target))

            if target is -1:
                i += 1
                continue
            elif target is -2:
                # delete
                i = i-1
                # find last image path and meta path inside the category
                image_meta_path = self.target_files[i]
                for j in range(self.nb_categories):
                    if image_meta_path in self.files_per_categories[j]:
                        meta_path = image_meta_path[1]
                        # open the meta file and remove the category key
                        with open(meta_path, &#39;r&#39;) as f:
                            meta = json.load(f)
                        groundtruth = meta[&#34;groundtruth&#34;]
                        del groundtruth[&#34;category&#34;]
                        meta[&#34;groundtruth&#34;] = groundtruth
                        with open(meta_path, &#39;w&#39;) as f:
                            json.dump(meta, f, indent=4, sort_keys=True)
                        self.files_per_categories[j].remove(image_meta_path)
                        print(&#34;File removed from category!&#34;)
                        break

                # Redisplay the previous category image inside the grid
                last_cat_img_meta_path = self.files_per_categories[int_cat][len(self.files_per_categories[int_cat])-1]
                image_path = last_cat_img_meta_path[0]
                meta_path = last_cat_img_meta_path[1]
                img = cv2.imread(image_path)
                with open(meta_path, &#39;r&#39;) as f:
                    meta = json.load(f)
                str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
                int_cat = self.convert_cat_str_to_int(str_cat)
                self.reload_grid_category(img, int_cat)
                continue
            else:
                with open(meta_path, &#39;r&#39;) as f:
                    meta = json.load(f)
                meta[&#34;groundtruth&#34;][&#34;category&#34;] = target
                with open(meta_path, &#39;w&#39;) as f:
                    json.dump(meta, f, indent=4, sort_keys=True)
                int_cat = self.convert_cat_str_to_int(target)
                self.files_per_categories[int_cat].append(image_meta_path)

                self.reload_grid_category(img, int_cat)

            i = i + 1

            print(&#34;{} more to go!&#34;.format(len(self.target_files)-i))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.add_to_category"><code class="name flex">
<span>def <span class="ident">add_to_category</span></span>(<span>self, image_path, meta_path, cat_nb)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an <code>image_path</code> and <code>meta_path</code> to a category <code>cat_nb</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_category(self, image_path, meta_path, cat_nb):
    &#34;&#34;&#34;
    Add an `image_path` and `meta_path` to a category `cat_nb`
    &#34;&#34;&#34;
    self.files_per_categories[cat_nb].append([image_path, meta_path])</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_categories"><code class="name flex">
<span>def <span class="ident">build_categories</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the interface after initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_categories(self):
    &#34;&#34;&#34;
    Run the interface after initialization.
    &#34;&#34;&#34;
    i = 0

    window_name = &#39;image&#39;

    while i &lt; len(self.target_files):

        image_meta_path = self.target_files[i]
        image_path = image_meta_path[0]
        meta_path = image_meta_path[1]
        print(image_path)

        img = cv2.imread(image_path)
        cv2.imshow(window_name, img)

        cv2.imshow(&#39;Category&#39;, self.final_img_r)

        k = cv2.waitKey(0)

        if k &gt;= 48 and k &lt;= 57:
            target = str(k % 48)
        elif k == 100:
            target = &#39;d&#39;
        elif k == 117:
            target = &#39;u&#39;
        elif k == 8 : #back
            target = -2
        else:
            target = -1

        print(&#34;target = {}&#34;.format(target))

        if target is -1:
            i += 1
            continue
        elif target is -2:
            # delete
            i = i-1
            # find last image path and meta path inside the category
            image_meta_path = self.target_files[i]
            for j in range(self.nb_categories):
                if image_meta_path in self.files_per_categories[j]:
                    meta_path = image_meta_path[1]
                    # open the meta file and remove the category key
                    with open(meta_path, &#39;r&#39;) as f:
                        meta = json.load(f)
                    groundtruth = meta[&#34;groundtruth&#34;]
                    del groundtruth[&#34;category&#34;]
                    meta[&#34;groundtruth&#34;] = groundtruth
                    with open(meta_path, &#39;w&#39;) as f:
                        json.dump(meta, f, indent=4, sort_keys=True)
                    self.files_per_categories[j].remove(image_meta_path)
                    print(&#34;File removed from category!&#34;)
                    break

            # Redisplay the previous category image inside the grid
            last_cat_img_meta_path = self.files_per_categories[int_cat][len(self.files_per_categories[int_cat])-1]
            image_path = last_cat_img_meta_path[0]
            meta_path = last_cat_img_meta_path[1]
            img = cv2.imread(image_path)
            with open(meta_path, &#39;r&#39;) as f:
                meta = json.load(f)
            str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
            int_cat = self.convert_cat_str_to_int(str_cat)
            self.reload_grid_category(img, int_cat)
            continue
        else:
            with open(meta_path, &#39;r&#39;) as f:
                meta = json.load(f)
            meta[&#34;groundtruth&#34;][&#34;category&#34;] = target
            with open(meta_path, &#39;w&#39;) as f:
                json.dump(meta, f, indent=4, sort_keys=True)
            int_cat = self.convert_cat_str_to_int(target)
            self.files_per_categories[int_cat].append(image_meta_path)

            self.reload_grid_category(img, int_cat)

        i = i + 1

        print(&#34;{} more to go!&#34;.format(len(self.target_files)-i))</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_target_list"><code class="name flex">
<span>def <span class="ident">build_target_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a list of target files. Each target file is a tuple paths ('imagepath', 'metapath') to load the files.</p>
<p>Return a list of tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_target_list(self):
    &#34;&#34;&#34;
    Build a list of target files. Each target file is a tuple paths (&#39;imagepath&#39;, &#39;metapath&#39;) to load the files.\n
    Return a list of tuples. 
    &#34;&#34;&#34;
    target_files = []
    for subdir, dirs, files in os.walk(self.image_folder, topdown=True):
        for file in files:
            imagepath = os.path.join(subdir, file)
            metapath = os.path.join(self.meta_folder,
                                     os.path.basename(subdir),
                                     os.path.splitext(file)[0]+&#34;.meta&#34;)
            with open(metapath, &#39;r&#39;) as f:
                meta = json.load(f)
            if not &#34;groundtruth&#34; in meta:
                continue
            elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                continue
            elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                continue
            elif &#34;category&#34; in meta[&#34;groundtruth&#34;]:
                str_cat = meta[&#34;groundtruth&#34;][&#34;category&#34;]
                int_cat = self.convert_cat_str_to_int(str_cat)
                self.files_per_categories[int_cat].append([imagepath, metapath])
                continue
            target_files.append([imagepath, metapath])
    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.convert_cat_str_to_int"><code class="name flex">
<span>def <span class="ident">convert_cat_str_to_int</span></span>(<span>self, str_cat)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string into an int. </p>
<p><code>str_cat</code>: the category as string </p>
<p>Returns an int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_cat_str_to_int(self, str_cat):
    &#34;&#34;&#34;
    Convert a string into an int. \n
    `str_cat`: the category as string \n
    Returns an int
    &#34;&#34;&#34;
    for i in range(10):
        if str_cat == str(i):
            return i
    if str_cat == &#34;d&#34;:
        return 10
    elif str_cat == &#34;u&#34;:
        return 11</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.load_last_image_per_category"><code class="name flex">
<span>def <span class="ident">load_last_image_per_category</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the last image of each category and group them into one image for display.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_last_image_per_category(self):
    &#34;&#34;&#34;
    Load the last image of each category and group them into one image for display.
    &#34;&#34;&#34;
    self.nb_row = 4
    self.nb_col = 3
    self.img_width = 640
    self.img_height = 640
    self.final_img = np.zeros((self.img_width*self.nb_row, self.img_height*self.nb_col, 3))
    i = 0
    j = 0

    for i in range(len(self.files_per_categories)):
        nb_cat = i
        files_cat = self.files_per_categories[nb_cat]
        if len(files_cat) == 0:
            continue
        last_image_meta_path = files_cat[len(files_cat)-1]
        last_image_path = last_image_meta_path[0]
        last_meta_path = last_image_meta_path[1]

        img = cv2.imread(last_image_path)
        img = img/256
        # img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
        # print(img_r.shape)
        i = nb_cat // self.nb_col
        j = nb_cat % self.nb_col

        self.final_img[i * self.img_width:(i+1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img

    self.final_img_r = cv2.resize(self.final_img, (640, 640))</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.reload_grid_category"><code class="name flex">
<span>def <span class="ident">reload_grid_category</span></span>(<span>self, img, nb_cat)</span>
</code></dt>
<dd>
<div class="desc"><p>Reload the grid of the last image per category.</p>
<p><code>nb_cat</code>: the category number</p>
<p><code>img</code>: the image to add to the grid</p>
<p>Display the grid of images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload_grid_category(self, img, nb_cat):
    &#34;&#34;&#34;
    Reload the grid of the last image per category.\n
    `nb_cat`: the category number\n
    `img`: the image to add to the grid\n
    Display the grid of images
    &#34;&#34;&#34;
    img = img/256
    i = nb_cat // self.nb_col
    j = nb_cat % self.nb_col
    img_r = cv2.resize(img.copy(), (self.img_width, self.img_height))
    self.final_img[i * self.img_width:(i + 1) * self.img_width, j * self.img_height:(j + 1) * self.img_height, :] = img_r
    self.final_img_r = cv2.resize(self.final_img, (640,640))
    cv2.imshow(&#39;Category&#39;, self.final_img_r)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.database_management" href="index.html">helipad_detection.src.database_management</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2">DatabaseCategoriesv2</a></code></h4>
<ul class="">
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.add_to_category" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.add_to_category">add_to_category</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_categories" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_categories">build_categories</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_target_list" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.build_target_list">build_target_list</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.convert_cat_str_to_int" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.convert_cat_str_to_int">convert_cat_str_to_int</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.load_last_image_per_category" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.load_last_image_per_category">load_last_image_per_category</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.reload_grid_category" href="#helipad_detection.src.database_management.database_categories_v2.DatabaseCategoriesv2.reload_grid_category">reload_grid_category</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>