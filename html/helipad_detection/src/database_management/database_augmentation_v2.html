<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.database_management.database_augmentation_v2 API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.database_management.database_augmentation_v2</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import json
import cv2
import time
import argparse
from tqdm import tqdm
import numpy as np

import imgaug as ia
from imgaug import augmenters as iaa
from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage 

import sys
sys.path.append(&#39;../&#39;)

os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;
os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;0&#34;


class DatabaseAugmentationV2:
    
    &#34;&#34;&#34;
    Apply Augmentation on the dataset using an ImgAug augmentation sequence 
    &#34;&#34;&#34;
    
    def __init__(self, input_folder, meta_folder, root_folder, root_folder_meta,
                 augmentation_strategy, version_number,
                 balance_dataset=False, repartition=None):
        
        &#34;&#34;&#34;
        `input_folder`: the folder containing the original images \n
        `meta_folder`: the folder containing the meta of the original images \n
        `root_folder`: the folder where to store the augmented images \n
        `root_folder_meta`: the folder where to store the meta of the augmented images \n
        `augmentation_strategy`: an ImgAug augmentation sequence \n
        `version_number`: the augmentation version number. The suffix of the output folder will be the version number \n 
        `balance_dataset`: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories \n
        `repartition`: list of 12 integers precising the number of times each image per category is augmented  \n
        &#34;&#34;&#34;
        
        self.input_folder = input_folder
        self.meta_folder = meta_folder
        self.root_folder = root_folder
        self.root_folder_meta = root_folder_meta
        self.augmentation_strategy = augmentation_strategy
        self.version_number = version_number
        
        self.aug_foldername = self.set_aug_foldername(self.root_folder, version_number)
        self.output_folder = os.path.join(root_folder, self.aug_foldername)
        self.aug_meta_foldername = self.set_aug_foldername(self.root_folder_meta, version_number)
        self.meta_output_folder = os.path.join(os.path.dirname(self.meta_folder), self.aug_meta_foldername)

        if not os.path.isdir(self.output_folder):
            os.mkdir(self.output_folder)
        if not os.path.isdir(self.meta_output_folder):
            os.mkdir(self.meta_output_folder)

        self.balance_dataset = balance_dataset
        self.repartition = repartition

        print(&#34;Building Target files&#34;)
        if self.balance_dataset:
            self.target_files = self.balance_categories(self.input_folder, self.meta_folder, repartition)
        elif repartition:
            self.target_files = self.duplicate_categories(self.input_folder, self.meta_folder, repartition)
        else:
            self.target_files = self.build_target_files()
        print(&#34;Target Files Built&#34;)
        print(&#34;Generating {} images&#34;.format(len(self.target_files)))

    @staticmethod
    def set_aug_foldername(folder, version_number=None):
        &#34;&#34;&#34;
        Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
        &#34;&#34;&#34;
        if version_number == None:
            directories = os.listdir(folder)
            print(directories)
            i = 1
            for dir in directories:
                if dir[0] == &#39;.&#39;:
                    continue
                elements = dir.split(&#39;_&#39;)
                if elements[-2] == &#39;augmented&#39;:
                    i += 1
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
        else:
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
        return aug_foldername

    @staticmethod
    def set_aug_filename(filename, i):
        &#34;&#34;&#34;
        Set the augmentation filename using the `filename` and its augmentation id `i`.
        &#34;&#34;&#34;
        filename_ext = os.path.splitext(filename)
        aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
        return aug_filename
    
    def set_aug_image_meta_path(self, filename, subdir):
        &#34;&#34;&#34;
        Save image inside the database folder with the meta file
        &#34;&#34;&#34;
        aug_filename = self.set_aug_filename(filename, 0)
        folder_name = os.path.basename(subdir)
        folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

        i = 0
        while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
            i += 1
            # print(&#34;File Exists : {}&#34;.format(aug_filename))
            aug_filename_ext = os.path.splitext(aug_filename)
            new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
            aug_filename = new_aug_filename

        # print(&#34;Saving to : {}&#34;.format(aug_filename))

        aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

        aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
        aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)
        
        return aug_image_filepath, aug_meta_filepath

    @staticmethod
    def categories_imagemeta_path(input_folder, meta_folder):
        &#34;&#34;&#34;
        Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
        &#34;&#34;&#34;
        categories_path = {}
        for subdir, dirs, files in os.walk(input_folder, topdown=True):
            for file in files:
                image_path = os.path.join(subdir, file)
                meta_filepath = os.path.join(meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

                if category not in categories_path:
                    categories_path[category] = [[image_path, meta_filepath]]
                else:
                    categories_path[category].append([image_path, meta_filepath])
        return categories_path

    @staticmethod
    def duplicate_categories(input_folder, meta_folder, repartition):
        &#34;&#34;&#34;
        Duplicate the categories respectively to the `repartition` chosen\n
        Return a list of target files
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        target_files = []

        for key, value in categories_path.items():
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat = int(key)
            if key == &#34;d&#34;:
                cat = 10
            if key == &#34;u&#34;:
                cat = 11

            for k in range(repartition[cat]):
                target_files.extend(value)

        return target_files

    @staticmethod
    def balance_categories(input_folder, meta_folder, repartition=None):
        &#34;&#34;&#34;
        Balance the categories first and then apply the `repartition` chosen \n
        Return a list of target files. 
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentationV2.categories_imagemeta_path(input_folder, meta_folder)
        categories_count = []
        categories_count_dict = {}
        for key, value in categories_path.items():
            categories_count.append(len(value))
            categories_count_dict[key] = len(value)
        print(&#34;Categories count : &#34;, end=&#34;&#34;)
        print(categories_count)
        print(categories_count_dict)
        max_count = np.amax(categories_count)
        print(&#34;Max count : &#34;, end=&#34;&#34;)
        print(max_count)
        total_count = np.sum(categories_count)
        print(&#34;Total count : &#34;, end=&#34;&#34;)
        print(total_count)

        target_files = []

        for key, value in categories_path.items():
            target_files.extend(value)
            L = len(value)

            nb_image_to_balance = max_count-L

            picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
            picked = list(np.array(value)[picked_index])
            target_files.extend(picked)

            # After Balance, duplicate categories
            if repartition:
                if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                    cat_int = int(key)
                elif key == &#34;d&#34;:
                    cat_int = 10
                elif key == &#34;u&#34;:
                    cat_int = 11

                nb_duplicate = repartition[cat_int]
                print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

                for i in range(nb_duplicate):
                    picked_index = np.random.choice(L, max_count, replace=True)
                    picked = list(np.array(value)[picked_index])
                    target_files.extend(picked)

        return target_files

    def build_target_files(self):
        &#34;&#34;&#34;
        Return a list of target files from the `input_folder`.
        &#34;&#34;&#34;
        target_files = []

        for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
            for file in files:
                meta_filepath = os.path.join(self.meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

                if len(bboxes) == 0:
                    continue

                target_files.append([os.path.join(subdir, file), meta_filepath])

        return target_files
    
    @staticmethod
    def load_image_bboxes(image_path, meta_path):
        &#34;&#34;&#34;
        Load the bounding boxes of the image from `image_path` and `meta_path`
        &#34;&#34;&#34;
        image = cv2.imread(image_path)
        with open(meta_path, &#39;r&#39;) as f:
            meta = json.load(f)
        bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]
        # reorder boxes
        bboxes_reordered = []
        for box in bboxes:
            min_x = min(box[0], box[2])
            min_y = min(box[1], box[3])
            max_x = max(box[0], box[2])
            max_y = max(box[1], box[3])
            bboxes_reordered.append([min_x, min_y, max_x, max_y])
        return image, bboxes, meta
    
    @staticmethod
    def load_image_box_for_aug(image, bboxes):
        &#34;&#34;&#34;
        Convert the bounding boxes to ImgAug bounding boxes format \n
        Returns the image with the bounding boxes.
        &#34;&#34;&#34;
        bb = []
        for box in bboxes:
            bb.append(BoundingBox(x1=box[0], x2=box[2], y1=box[1], y2=box[3]))
        bbs = BoundingBoxesOnImage(bb, shape=image.shape)
        return image, bbs
    
    @staticmethod
    def apply_aug(image, bbs, aug):
        &#34;&#34;&#34;
        Apply the augmentation on the image using the ImgAug bounding boxes format\n
        Return the augmented image with the augmented bounding boxes
        &#34;&#34;&#34;
        image_aug, bbs_aug = aug(image=image, bounding_boxes=bbs)
        bbs_aug = bbs_aug.remove_out_of_image().clip_out_of_image()
        return image_aug, bbs_aug
    
    def apply_augmentation_on_image(self, image, meta, bboxes):
        &#34;&#34;&#34;
        Apply augmentation on the image using the image and meta files\n
        Return the augmented image with the augmented bounding boxes as a list.
        &#34;&#34;&#34;
        image, bbs = self.load_image_box_for_aug(image, bboxes)
        image_aug, bbs_aug = self.apply_aug(image, bbs, self.augmentation_strategy)
        bboxes_aug = []
        for bounding_box in bbs_aug.bounding_boxes:
            xmin = int(bounding_box[0][0])
            ymin = int(bounding_box[0][1])
            xmax = int(bounding_box[1][0])
            ymax = int(bounding_box[1][1])
            bboxes_aug.append([xmin, ymin, xmax, ymax])
        return image_aug, bboxes_aug
    
    @staticmethod
    def save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path):
        &#34;&#34;&#34;
        Save the augmented image and meta
        &#34;&#34;&#34;
        if not os.path.isdir(os.path.dirname(image_aug_path)):
                os.mkdir(os.path.dirname(image_aug_path))
        if not os.path.isdir(os.path.dirname(meta_aug_path)):
                os.mkdir(os.path.dirname(meta_aug_path))
        meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
        if &#34;predicted&#34; in meta:
            del meta[&#34;predicted&#34;]
        with open(meta_aug_path, &#39;w&#39;) as f:
            json.dump(meta, f, sort_keys=True, indent=4)
        cv2.imwrite(image_aug_path, image_aug)

    def run(self):
        &#34;&#34;&#34;
        Run the augmentation on the dataset after initialization
        &#34;&#34;&#34;
        for i in tqdm(range(len(self.target_files))):

            image_meta_path = self.target_files[i]

            image_path = image_meta_path[0]
            filename = os.path.basename(image_path)
            subdir = os.path.dirname(image_path)
            meta_filepath = image_meta_path[1]

            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                print(&#34;{} has no box&#34;.format(filename))
                continue

            image, bboxes, meta = self.load_image_bboxes(image_path, meta_filepath)
            
            image_aug_path, meta_aug_path = self.set_aug_image_meta_path(filename, subdir)
            
            image_aug, bboxes_aug = self.apply_augmentation_on_image(image,
                                                                     meta,
                                                                     bboxes)
            
            
            aug_meta = meta.copy()
            aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
            
            self.save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path)


if __name__ == &#34;__main__&#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;-d&#39;, dest=&#39;display_sample&#39;, default=False)
    args = parser.parse_args()
    display_sample = args.display_sample

    # input_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase&#39;, &#39;Helipad_DataBase_original&#39;)
    # meta_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase_meta&#39;, &#39;Helipad_DataBase_meta_original&#39;)
    # root_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase&#39;)
    # root_folder_meta = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase_meta&#39;)

    input_folder = &#34;../../Helipad_DataBase/Helipad_DataBase_original&#34;
    meta_folder = &#34;../../Helipad_DataBase_meta/Helipad_DataBase_meta_original&#34;
    root_folder = &#34;../../Helipad_DataBase&#34;
    root_folder_meta = &#34;../../Helipad_DataBase_meta&#34;

    balance_dataset = True

    # repartition = None
    #              0  1  2  3  4  5  6  7  8  9  d  u
    repartition = [4, 4, 4, 5, 3, 4, 5, 5, 6, 6, 6, 4]

    database_augmentation = DatabaseAugmentation(input_folder,
                                                 meta_folder,
                                                 root_folder,
                                                 root_folder_meta,
                                                 balance_dataset,
                                                 repartition,
                                                 display_sample)

    database_augmentation.run()

    print(&#34;Augmentation Done!&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2"><code class="flex name class">
<span>class <span class="ident">DatabaseAugmentationV2</span></span>
<span>(</span><span>input_folder, meta_folder, root_folder, root_folder_meta, augmentation_strategy, version_number, balance_dataset=False, repartition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply Augmentation on the dataset using an ImgAug augmentation sequence </p>
<p><code>input_folder</code>: the folder containing the original images </p>
<p><code>meta_folder</code>: the folder containing the meta of the original images </p>
<p><code>root_folder</code>: the folder where to store the augmented images </p>
<p><code>root_folder_meta</code>: the folder where to store the meta of the augmented images </p>
<p><code>augmentation_strategy</code>: an ImgAug augmentation sequence </p>
<p><code>version_number</code>: the augmentation version number. The suffix of the output folder will be the version number </p>
<p><code>balance_dataset</code>: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories </p>
<p><code>repartition</code>: list of 12 integers precising the number of times each image per category is augmented</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatabaseAugmentationV2:
    
    &#34;&#34;&#34;
    Apply Augmentation on the dataset using an ImgAug augmentation sequence 
    &#34;&#34;&#34;
    
    def __init__(self, input_folder, meta_folder, root_folder, root_folder_meta,
                 augmentation_strategy, version_number,
                 balance_dataset=False, repartition=None):
        
        &#34;&#34;&#34;
        `input_folder`: the folder containing the original images \n
        `meta_folder`: the folder containing the meta of the original images \n
        `root_folder`: the folder where to store the augmented images \n
        `root_folder_meta`: the folder where to store the meta of the augmented images \n
        `augmentation_strategy`: an ImgAug augmentation sequence \n
        `version_number`: the augmentation version number. The suffix of the output folder will be the version number \n 
        `balance_dataset`: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories \n
        `repartition`: list of 12 integers precising the number of times each image per category is augmented  \n
        &#34;&#34;&#34;
        
        self.input_folder = input_folder
        self.meta_folder = meta_folder
        self.root_folder = root_folder
        self.root_folder_meta = root_folder_meta
        self.augmentation_strategy = augmentation_strategy
        self.version_number = version_number
        
        self.aug_foldername = self.set_aug_foldername(self.root_folder, version_number)
        self.output_folder = os.path.join(root_folder, self.aug_foldername)
        self.aug_meta_foldername = self.set_aug_foldername(self.root_folder_meta, version_number)
        self.meta_output_folder = os.path.join(os.path.dirname(self.meta_folder), self.aug_meta_foldername)

        if not os.path.isdir(self.output_folder):
            os.mkdir(self.output_folder)
        if not os.path.isdir(self.meta_output_folder):
            os.mkdir(self.meta_output_folder)

        self.balance_dataset = balance_dataset
        self.repartition = repartition

        print(&#34;Building Target files&#34;)
        if self.balance_dataset:
            self.target_files = self.balance_categories(self.input_folder, self.meta_folder, repartition)
        elif repartition:
            self.target_files = self.duplicate_categories(self.input_folder, self.meta_folder, repartition)
        else:
            self.target_files = self.build_target_files()
        print(&#34;Target Files Built&#34;)
        print(&#34;Generating {} images&#34;.format(len(self.target_files)))

    @staticmethod
    def set_aug_foldername(folder, version_number=None):
        &#34;&#34;&#34;
        Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
        &#34;&#34;&#34;
        if version_number == None:
            directories = os.listdir(folder)
            print(directories)
            i = 1
            for dir in directories:
                if dir[0] == &#39;.&#39;:
                    continue
                elements = dir.split(&#39;_&#39;)
                if elements[-2] == &#39;augmented&#39;:
                    i += 1
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
        else:
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
        return aug_foldername

    @staticmethod
    def set_aug_filename(filename, i):
        &#34;&#34;&#34;
        Set the augmentation filename using the `filename` and its augmentation id `i`.
        &#34;&#34;&#34;
        filename_ext = os.path.splitext(filename)
        aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
        return aug_filename
    
    def set_aug_image_meta_path(self, filename, subdir):
        &#34;&#34;&#34;
        Save image inside the database folder with the meta file
        &#34;&#34;&#34;
        aug_filename = self.set_aug_filename(filename, 0)
        folder_name = os.path.basename(subdir)
        folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

        i = 0
        while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
            i += 1
            # print(&#34;File Exists : {}&#34;.format(aug_filename))
            aug_filename_ext = os.path.splitext(aug_filename)
            new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
            aug_filename = new_aug_filename

        # print(&#34;Saving to : {}&#34;.format(aug_filename))

        aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

        aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
        aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)
        
        return aug_image_filepath, aug_meta_filepath

    @staticmethod
    def categories_imagemeta_path(input_folder, meta_folder):
        &#34;&#34;&#34;
        Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
        &#34;&#34;&#34;
        categories_path = {}
        for subdir, dirs, files in os.walk(input_folder, topdown=True):
            for file in files:
                image_path = os.path.join(subdir, file)
                meta_filepath = os.path.join(meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

                if category not in categories_path:
                    categories_path[category] = [[image_path, meta_filepath]]
                else:
                    categories_path[category].append([image_path, meta_filepath])
        return categories_path

    @staticmethod
    def duplicate_categories(input_folder, meta_folder, repartition):
        &#34;&#34;&#34;
        Duplicate the categories respectively to the `repartition` chosen\n
        Return a list of target files
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        target_files = []

        for key, value in categories_path.items():
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat = int(key)
            if key == &#34;d&#34;:
                cat = 10
            if key == &#34;u&#34;:
                cat = 11

            for k in range(repartition[cat]):
                target_files.extend(value)

        return target_files

    @staticmethod
    def balance_categories(input_folder, meta_folder, repartition=None):
        &#34;&#34;&#34;
        Balance the categories first and then apply the `repartition` chosen \n
        Return a list of target files. 
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentationV2.categories_imagemeta_path(input_folder, meta_folder)
        categories_count = []
        categories_count_dict = {}
        for key, value in categories_path.items():
            categories_count.append(len(value))
            categories_count_dict[key] = len(value)
        print(&#34;Categories count : &#34;, end=&#34;&#34;)
        print(categories_count)
        print(categories_count_dict)
        max_count = np.amax(categories_count)
        print(&#34;Max count : &#34;, end=&#34;&#34;)
        print(max_count)
        total_count = np.sum(categories_count)
        print(&#34;Total count : &#34;, end=&#34;&#34;)
        print(total_count)

        target_files = []

        for key, value in categories_path.items():
            target_files.extend(value)
            L = len(value)

            nb_image_to_balance = max_count-L

            picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
            picked = list(np.array(value)[picked_index])
            target_files.extend(picked)

            # After Balance, duplicate categories
            if repartition:
                if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                    cat_int = int(key)
                elif key == &#34;d&#34;:
                    cat_int = 10
                elif key == &#34;u&#34;:
                    cat_int = 11

                nb_duplicate = repartition[cat_int]
                print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

                for i in range(nb_duplicate):
                    picked_index = np.random.choice(L, max_count, replace=True)
                    picked = list(np.array(value)[picked_index])
                    target_files.extend(picked)

        return target_files

    def build_target_files(self):
        &#34;&#34;&#34;
        Return a list of target files from the `input_folder`.
        &#34;&#34;&#34;
        target_files = []

        for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
            for file in files:
                meta_filepath = os.path.join(self.meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

                if len(bboxes) == 0:
                    continue

                target_files.append([os.path.join(subdir, file), meta_filepath])

        return target_files
    
    @staticmethod
    def load_image_bboxes(image_path, meta_path):
        &#34;&#34;&#34;
        Load the bounding boxes of the image from `image_path` and `meta_path`
        &#34;&#34;&#34;
        image = cv2.imread(image_path)
        with open(meta_path, &#39;r&#39;) as f:
            meta = json.load(f)
        bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]
        # reorder boxes
        bboxes_reordered = []
        for box in bboxes:
            min_x = min(box[0], box[2])
            min_y = min(box[1], box[3])
            max_x = max(box[0], box[2])
            max_y = max(box[1], box[3])
            bboxes_reordered.append([min_x, min_y, max_x, max_y])
        return image, bboxes, meta
    
    @staticmethod
    def load_image_box_for_aug(image, bboxes):
        &#34;&#34;&#34;
        Convert the bounding boxes to ImgAug bounding boxes format \n
        Returns the image with the bounding boxes.
        &#34;&#34;&#34;
        bb = []
        for box in bboxes:
            bb.append(BoundingBox(x1=box[0], x2=box[2], y1=box[1], y2=box[3]))
        bbs = BoundingBoxesOnImage(bb, shape=image.shape)
        return image, bbs
    
    @staticmethod
    def apply_aug(image, bbs, aug):
        &#34;&#34;&#34;
        Apply the augmentation on the image using the ImgAug bounding boxes format\n
        Return the augmented image with the augmented bounding boxes
        &#34;&#34;&#34;
        image_aug, bbs_aug = aug(image=image, bounding_boxes=bbs)
        bbs_aug = bbs_aug.remove_out_of_image().clip_out_of_image()
        return image_aug, bbs_aug
    
    def apply_augmentation_on_image(self, image, meta, bboxes):
        &#34;&#34;&#34;
        Apply augmentation on the image using the image and meta files\n
        Return the augmented image with the augmented bounding boxes as a list.
        &#34;&#34;&#34;
        image, bbs = self.load_image_box_for_aug(image, bboxes)
        image_aug, bbs_aug = self.apply_aug(image, bbs, self.augmentation_strategy)
        bboxes_aug = []
        for bounding_box in bbs_aug.bounding_boxes:
            xmin = int(bounding_box[0][0])
            ymin = int(bounding_box[0][1])
            xmax = int(bounding_box[1][0])
            ymax = int(bounding_box[1][1])
            bboxes_aug.append([xmin, ymin, xmax, ymax])
        return image_aug, bboxes_aug
    
    @staticmethod
    def save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path):
        &#34;&#34;&#34;
        Save the augmented image and meta
        &#34;&#34;&#34;
        if not os.path.isdir(os.path.dirname(image_aug_path)):
                os.mkdir(os.path.dirname(image_aug_path))
        if not os.path.isdir(os.path.dirname(meta_aug_path)):
                os.mkdir(os.path.dirname(meta_aug_path))
        meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
        if &#34;predicted&#34; in meta:
            del meta[&#34;predicted&#34;]
        with open(meta_aug_path, &#39;w&#39;) as f:
            json.dump(meta, f, sort_keys=True, indent=4)
        cv2.imwrite(image_aug_path, image_aug)

    def run(self):
        &#34;&#34;&#34;
        Run the augmentation on the dataset after initialization
        &#34;&#34;&#34;
        for i in tqdm(range(len(self.target_files))):

            image_meta_path = self.target_files[i]

            image_path = image_meta_path[0]
            filename = os.path.basename(image_path)
            subdir = os.path.dirname(image_path)
            meta_filepath = image_meta_path[1]

            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                print(&#34;{} has no box&#34;.format(filename))
                continue

            image, bboxes, meta = self.load_image_bboxes(image_path, meta_filepath)
            
            image_aug_path, meta_aug_path = self.set_aug_image_meta_path(filename, subdir)
            
            image_aug, bboxes_aug = self.apply_augmentation_on_image(image,
                                                                     meta,
                                                                     bboxes)
            
            
            aug_meta = meta.copy()
            aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
            
            self.save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_aug"><code class="name flex">
<span>def <span class="ident">apply_aug</span></span>(<span>image, bbs, aug)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the augmentation on the image using the ImgAug bounding boxes format</p>
<p>Return the augmented image with the augmented bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def apply_aug(image, bbs, aug):
    &#34;&#34;&#34;
    Apply the augmentation on the image using the ImgAug bounding boxes format\n
    Return the augmented image with the augmented bounding boxes
    &#34;&#34;&#34;
    image_aug, bbs_aug = aug(image=image, bounding_boxes=bbs)
    bbs_aug = bbs_aug.remove_out_of_image().clip_out_of_image()
    return image_aug, bbs_aug</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.balance_categories"><code class="name flex">
<span>def <span class="ident">balance_categories</span></span>(<span>input_folder, meta_folder, repartition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Balance the categories first and then apply the <code>repartition</code> chosen </p>
<p>Return a list of target files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def balance_categories(input_folder, meta_folder, repartition=None):
    &#34;&#34;&#34;
    Balance the categories first and then apply the `repartition` chosen \n
    Return a list of target files. 
    &#34;&#34;&#34;
    categories_path = DatabaseAugmentationV2.categories_imagemeta_path(input_folder, meta_folder)
    categories_count = []
    categories_count_dict = {}
    for key, value in categories_path.items():
        categories_count.append(len(value))
        categories_count_dict[key] = len(value)
    print(&#34;Categories count : &#34;, end=&#34;&#34;)
    print(categories_count)
    print(categories_count_dict)
    max_count = np.amax(categories_count)
    print(&#34;Max count : &#34;, end=&#34;&#34;)
    print(max_count)
    total_count = np.sum(categories_count)
    print(&#34;Total count : &#34;, end=&#34;&#34;)
    print(total_count)

    target_files = []

    for key, value in categories_path.items():
        target_files.extend(value)
        L = len(value)

        nb_image_to_balance = max_count-L

        picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
        picked = list(np.array(value)[picked_index])
        target_files.extend(picked)

        # After Balance, duplicate categories
        if repartition:
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat_int = int(key)
            elif key == &#34;d&#34;:
                cat_int = 10
            elif key == &#34;u&#34;:
                cat_int = 11

            nb_duplicate = repartition[cat_int]
            print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

            for i in range(nb_duplicate):
                picked_index = np.random.choice(L, max_count, replace=True)
                picked = list(np.array(value)[picked_index])
                target_files.extend(picked)

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.categories_imagemeta_path"><code class="name flex">
<span>def <span class="ident">categories_imagemeta_path</span></span>(<span>input_folder, meta_folder)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def categories_imagemeta_path(input_folder, meta_folder):
    &#34;&#34;&#34;
    Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
    &#34;&#34;&#34;
    categories_path = {}
    for subdir, dirs, files in os.walk(input_folder, topdown=True):
        for file in files:
            image_path = os.path.join(subdir, file)
            meta_filepath = os.path.join(meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)
            if not &#34;groundtruth&#34; in meta:
                continue
            elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                continue
            elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                continue
            elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                continue

            category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

            if category not in categories_path:
                categories_path[category] = [[image_path, meta_filepath]]
            else:
                categories_path[category].append([image_path, meta_filepath])
    return categories_path</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.duplicate_categories"><code class="name flex">
<span>def <span class="ident">duplicate_categories</span></span>(<span>input_folder, meta_folder, repartition)</span>
</code></dt>
<dd>
<div class="desc"><p>Duplicate the categories respectively to the <code>repartition</code> chosen</p>
<p>Return a list of target files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def duplicate_categories(input_folder, meta_folder, repartition):
    &#34;&#34;&#34;
    Duplicate the categories respectively to the `repartition` chosen\n
    Return a list of target files
    &#34;&#34;&#34;
    categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
    target_files = []

    for key, value in categories_path.items():
        if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
            cat = int(key)
        if key == &#34;d&#34;:
            cat = 10
        if key == &#34;u&#34;:
            cat = 11

        for k in range(repartition[cat]):
            target_files.extend(value)

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_bboxes"><code class="name flex">
<span>def <span class="ident">load_image_bboxes</span></span>(<span>image_path, meta_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the bounding boxes of the image from <code>image_path</code> and <code>meta_path</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_image_bboxes(image_path, meta_path):
    &#34;&#34;&#34;
    Load the bounding boxes of the image from `image_path` and `meta_path`
    &#34;&#34;&#34;
    image = cv2.imread(image_path)
    with open(meta_path, &#39;r&#39;) as f:
        meta = json.load(f)
    bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]
    # reorder boxes
    bboxes_reordered = []
    for box in bboxes:
        min_x = min(box[0], box[2])
        min_y = min(box[1], box[3])
        max_x = max(box[0], box[2])
        max_y = max(box[1], box[3])
        bboxes_reordered.append([min_x, min_y, max_x, max_y])
    return image, bboxes, meta</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_box_for_aug"><code class="name flex">
<span>def <span class="ident">load_image_box_for_aug</span></span>(<span>image, bboxes)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the bounding boxes to ImgAug bounding boxes format </p>
<p>Returns the image with the bounding boxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_image_box_for_aug(image, bboxes):
    &#34;&#34;&#34;
    Convert the bounding boxes to ImgAug bounding boxes format \n
    Returns the image with the bounding boxes.
    &#34;&#34;&#34;
    bb = []
    for box in bboxes:
        bb.append(BoundingBox(x1=box[0], x2=box[2], y1=box[1], y2=box[3]))
    bbs = BoundingBoxesOnImage(bb, shape=image.shape)
    return image, bbs</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.save_aug"><code class="name flex">
<span>def <span class="ident">save_aug</span></span>(<span>image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the augmented image and meta</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path):
    &#34;&#34;&#34;
    Save the augmented image and meta
    &#34;&#34;&#34;
    if not os.path.isdir(os.path.dirname(image_aug_path)):
            os.mkdir(os.path.dirname(image_aug_path))
    if not os.path.isdir(os.path.dirname(meta_aug_path)):
            os.mkdir(os.path.dirname(meta_aug_path))
    meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
    if &#34;predicted&#34; in meta:
        del meta[&#34;predicted&#34;]
    with open(meta_aug_path, &#39;w&#39;) as f:
        json.dump(meta, f, sort_keys=True, indent=4)
    cv2.imwrite(image_aug_path, image_aug)</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_filename"><code class="name flex">
<span>def <span class="ident">set_aug_filename</span></span>(<span>filename, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the augmentation filename using the <code>filename</code> and its augmentation id <code>i</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_aug_filename(filename, i):
    &#34;&#34;&#34;
    Set the augmentation filename using the `filename` and its augmentation id `i`.
    &#34;&#34;&#34;
    filename_ext = os.path.splitext(filename)
    aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
    return aug_filename</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_foldername"><code class="name flex">
<span>def <span class="ident">set_aug_foldername</span></span>(<span>folder, version_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the augmented folder name with the suffix <code>version_number</code>. The output folder is a sub-directory of <code>folder</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_aug_foldername(folder, version_number=None):
    &#34;&#34;&#34;
    Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
    &#34;&#34;&#34;
    if version_number == None:
        directories = os.listdir(folder)
        print(directories)
        i = 1
        for dir in directories:
            if dir[0] == &#39;.&#39;:
                continue
            elements = dir.split(&#39;_&#39;)
            if elements[-2] == &#39;augmented&#39;:
                i += 1
        aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
    else:
        aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
    return aug_foldername</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_augmentation_on_image"><code class="name flex">
<span>def <span class="ident">apply_augmentation_on_image</span></span>(<span>self, image, meta, bboxes)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply augmentation on the image using the image and meta files</p>
<p>Return the augmented image with the augmented bounding boxes as a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_augmentation_on_image(self, image, meta, bboxes):
    &#34;&#34;&#34;
    Apply augmentation on the image using the image and meta files\n
    Return the augmented image with the augmented bounding boxes as a list.
    &#34;&#34;&#34;
    image, bbs = self.load_image_box_for_aug(image, bboxes)
    image_aug, bbs_aug = self.apply_aug(image, bbs, self.augmentation_strategy)
    bboxes_aug = []
    for bounding_box in bbs_aug.bounding_boxes:
        xmin = int(bounding_box[0][0])
        ymin = int(bounding_box[0][1])
        xmax = int(bounding_box[1][0])
        ymax = int(bounding_box[1][1])
        bboxes_aug.append([xmin, ymin, xmax, ymax])
    return image_aug, bboxes_aug</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.build_target_files"><code class="name flex">
<span>def <span class="ident">build_target_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of target files from the <code>input_folder</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_target_files(self):
    &#34;&#34;&#34;
    Return a list of target files from the `input_folder`.
    &#34;&#34;&#34;
    target_files = []

    for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
        for file in files:
            meta_filepath = os.path.join(self.meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)
            if not &#34;groundtruth&#34; in meta:
                continue
            elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                continue
            elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                continue

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                continue

            target_files.append([os.path.join(subdir, file), meta_filepath])

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the augmentation on the dataset after initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the augmentation on the dataset after initialization
    &#34;&#34;&#34;
    for i in tqdm(range(len(self.target_files))):

        image_meta_path = self.target_files[i]

        image_path = image_meta_path[0]
        filename = os.path.basename(image_path)
        subdir = os.path.dirname(image_path)
        meta_filepath = image_meta_path[1]

        with open(meta_filepath, &#39;r&#39;) as f:
            meta = json.load(f)

        bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

        if len(bboxes) == 0:
            print(&#34;{} has no box&#34;.format(filename))
            continue

        image, bboxes, meta = self.load_image_bboxes(image_path, meta_filepath)
        
        image_aug_path, meta_aug_path = self.set_aug_image_meta_path(filename, subdir)
        
        image_aug, bboxes_aug = self.apply_augmentation_on_image(image,
                                                                 meta,
                                                                 bboxes)
        
        
        aug_meta = meta.copy()
        aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug
        
        self.save_aug(image_aug, bboxes_aug, meta, meta_aug_path, image_aug_path)</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_image_meta_path"><code class="name flex">
<span>def <span class="ident">set_aug_image_meta_path</span></span>(<span>self, filename, subdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Save image inside the database folder with the meta file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_aug_image_meta_path(self, filename, subdir):
    &#34;&#34;&#34;
    Save image inside the database folder with the meta file
    &#34;&#34;&#34;
    aug_filename = self.set_aug_filename(filename, 0)
    folder_name = os.path.basename(subdir)
    folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

    i = 0
    while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
        i += 1
        # print(&#34;File Exists : {}&#34;.format(aug_filename))
        aug_filename_ext = os.path.splitext(aug_filename)
        new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
        aug_filename = new_aug_filename

    # print(&#34;Saving to : {}&#34;.format(aug_filename))

    aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

    aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
    aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)
    
    return aug_image_filepath, aug_meta_filepath</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.database_management" href="index.html">helipad_detection.src.database_management</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2">DatabaseAugmentationV2</a></code></h4>
<ul class="">
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_aug" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_aug">apply_aug</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_augmentation_on_image" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.apply_augmentation_on_image">apply_augmentation_on_image</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.balance_categories" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.balance_categories">balance_categories</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.build_target_files" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.build_target_files">build_target_files</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.categories_imagemeta_path" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.categories_imagemeta_path">categories_imagemeta_path</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.duplicate_categories" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.duplicate_categories">duplicate_categories</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_bboxes" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_bboxes">load_image_bboxes</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_box_for_aug" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.load_image_box_for_aug">load_image_box_for_aug</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.run" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.run">run</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.save_aug" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.save_aug">save_aug</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_filename" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_filename">set_aug_filename</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_foldername" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_foldername">set_aug_foldername</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_image_meta_path" href="#helipad_detection.src.database_management.database_augmentation_v2.DatabaseAugmentationV2.set_aug_image_meta_path">set_aug_image_meta_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>