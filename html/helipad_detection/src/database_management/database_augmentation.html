<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.database_management.database_augmentation API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.database_management.database_augmentation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import json
import cv2
import time
import argparse
from tqdm import tqdm

import numpy as np

os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;
os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;0&#34;

import tensorflow as tf

tf.enable_eager_execution()

# from imgaug import augmenters as iaa

from helipad_detection.src.utils.autoaugment_utils import *
from helipad_detection.src.utils.box_utils import *


class DatabaseAugmentation:
    &#34;&#34;&#34;
    Apply Augmentation on the dataset using Google&#39;s policy 
    &#34;&#34;&#34;
    def __init__(self, input_folder, meta_folder, root_folder, root_folder_meta,
                 balance_dataset=False, repartition=None, version_number=None, display=False):
        &#34;&#34;&#34;
        `input_folder`: the folder containing the original images \n
        `meta_folder`: the folder containing the meta of the original images \n
        `root_folder`: the folder where to store the augmented images \n
        `root_folder_meta`: the folder where to store the meta of the augmented images \n
        `balance_dataset`: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories \n
        `repartition`: list of 12 integers precising the number of times each image per category is augmented  \n
        `version_number`: the augmentation version number. The suffix of the output folder will be the version number \n 
        `display`: boolean to display the augmented images as the script augment them \n
        &#34;&#34;&#34;
        self.input_folder = input_folder
        self.meta_folder = meta_folder
        self.root_folder = root_folder
        self.root_folder_meta = root_folder_meta
        self.version_number = version_number
        self.aug_foldername = self.set_aug_foldername(self.root_folder, version_number=self.version_number)
        self.output_folder = os.path.join(root_folder, self.aug_foldername)
        self.aug_meta_foldername = self.set_aug_foldername(self.root_folder_meta, version_number=self.version_number)
        self.meta_output_folder = os.path.join(os.path.dirname(self.meta_folder), self.aug_meta_foldername)

        if not os.path.isdir(self.output_folder):
            os.mkdir(self.output_folder)
        if not os.path.isdir(self.meta_output_folder):
            os.mkdir(self.meta_output_folder)

        self.balance_dataset = balance_dataset
        self.repartition = repartition

        print(&#34;Building Target files&#34;)
        if self.balance_dataset:
            self.target_files = self.balance_categories(self.input_folder, self.meta_folder, repartition)
        elif repartition:
            self.target_files = self.duplicate_categories(self.input_folder, self.meta_folder, repartition)
        else:
            self.target_files = self.build_target_files()
        print(&#34;Target Files Built&#34;)
        print(&#34;Generating {} images&#34;.format(len(self.target_files)))

        if display == &#34;True&#34;:
            self.display = True
        elif display == &#34;False&#34;:
            self.display = False
        else:
            self.display = display

        print(type(self.display))
        print(&#34;Displaying samples : {}&#34;.format(self.display))
        self.sess = tf.InteractiveSession()

    @staticmethod
    def set_aug_foldername(folder, version_number=None):
        &#34;&#34;&#34;
        Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
        &#34;&#34;&#34;
        if not version_number:
            directories = os.listdir(folder)
            print(directories)
            i = 1
            for dir in directories:
                if dir[0] == &#39;.&#39;:
                    continue
                elements = dir.split(&#39;_&#39;)
                if elements[-2] == &#39;augmented&#39;:
                    i += 1
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
        else:
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
        return aug_foldername

    @staticmethod
    def set_aug_filename(filename, i):
        &#34;&#34;&#34;
        Set the augmentation filename using the `filename` and its augmentation id `i`.
        &#34;&#34;&#34;
        filename_ext = os.path.splitext(filename)
        aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
        return aug_filename

    @staticmethod
    def categories_imagemeta_path(input_folder, meta_folder):
        &#34;&#34;&#34;
        Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
        &#34;&#34;&#34;
        categories_path = {}
        for subdir, dirs, files in os.walk(input_folder, topdown=True):
            for file in files:
                image_path = os.path.join(subdir, file)
                meta_filepath = os.path.join(meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

                if category not in categories_path:
                    categories_path[category] = [[image_path, meta_filepath]]
                else:
                    categories_path[category].append([image_path, meta_filepath])
        return categories_path

    @staticmethod
    def duplicate_categories(input_folder, meta_folder, repartition):
        &#34;&#34;&#34;
        Duplicate the categories respectively to the `repartition` chosen\n
        Return a list of target files
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        target_files = []

        for key, value in categories_path.items():
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat = int(key)
            if key == &#34;d&#34;:
                cat = 10
            if key == &#34;u&#34;:
                cat = 11

            for k in range(repartition[cat]):
                target_files.extend(value)

        return target_files

    @staticmethod
    def balance_categories(input_folder, meta_folder, repartition=None):
        &#34;&#34;&#34;
        Balance the categories first and then apply the `repartition` chosen \n
        Return a list of target files. 
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        categories_count = []
        categories_count_dict = {}
        for key, value in categories_path.items():
            categories_count.append(len(value))
            categories_count_dict[key] = len(value)
        print(&#34;Categories count : &#34;, end=&#34;&#34;)
        print(categories_count)
        print(categories_count_dict)
        max_count = np.amax(categories_count)
        print(&#34;Max count : &#34;, end=&#34;&#34;)
        print(max_count)
        total_count = np.sum(categories_count)
        print(&#34;Total count : &#34;, end=&#34;&#34;)
        print(total_count)

        target_files = []

        for key, value in categories_path.items():
            target_files.extend(value)
            L = len(value)

            nb_image_to_balance = max_count-L

            # if nb_image_to_balance &lt;= L:
            #     picked_index = np.random.choice(L, nb_image_to_balance, replace=False)
            #     picked = list(np.array(value)[picked_index])
            # else:
            picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
            picked = list(np.array(value)[picked_index])
            target_files.extend(picked)

            # After Balance, duplicate categories
            if repartition:
                if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                    cat_int = int(key)
                elif key == &#34;d&#34;:
                    cat_int = 10
                elif key == &#34;u&#34;:
                    cat_int = 11

                nb_duplicate = repartition[cat_int]
                print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

                for i in range(nb_duplicate):
                    picked_index = np.random.choice(L, max_count, replace=True)
                    picked = list(np.array(value)[picked_index])
                    target_files.extend(picked)

        return target_files

    def build_target_files(self):
        &#34;&#34;&#34;
        Return a list of target files from the `input_folder`.
        &#34;&#34;&#34;
        target_files = []

        for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
            for file in files:
                meta_filepath = os.path.join(self.meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

                if len(bboxes) == 0:
                    continue

                target_files.append([os.path.join(subdir, file), meta_filepath])

        return target_files

    def run(self):
        &#34;&#34;&#34;
        Run the augmentation on the dataset after initialization
        &#34;&#34;&#34;

        for i in tqdm(range(len(self.target_files))):

            file_meta_path = self.target_files[i]

            filepath = file_meta_path[0]
            file = os.path.basename(filepath)
            subdir = os.path.dirname(filepath)
            meta_filepath = file_meta_path[1]

            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                print(&#34;{} has no box&#34;.format(file))
                continue

            # reorder boxes
            bboxes_reordered = []
            for box in bboxes:
                min_x = min(box[0], box[2])
                min_y = min(box[1], box[3])
                max_x = max(box[0], box[2])
                max_y = max(box[1], box[3])
                bboxes_reordered.append([min_y, min_x, max_y, max_x])
            bboxes_corrected = np.array(bboxes_reordered)

            image = np.asarray(cv2.imread(filepath), np.int32)
            image = tf.convert_to_tensor(image, np.int32)

            bboxes_normalized = normalize_boxes(bboxes_corrected, image.shape[:2])

            start = time.time()
            (augmented_images, augmented_bboxes) = distort_image_with_autoaugment(image, bboxes_normalized, &#39;v3&#39;)
            end = time.time()
            # print(&#34;Took : {}s to augment&#34;.format(end-start))
            augmented_bboxes = denormalize_boxes(augmented_bboxes, image.shape[:2])
            augmented_bboxes = tf.cast(augmented_bboxes, dtype=tf.int32)

            start = time.time()
            image_aug = augmented_images.numpy().astype(np.uint8)
            bboxes_aug = augmented_bboxes.numpy()
            end = time.time()
            # print(&#34;Took : {}s to retrieve results&#34;.format(end-start))
            # print(&#34;{}--&gt;{}--&gt;{}&#34;.format(bboxes, bboxes_corrected, bboxes_aug))

            bboxes_aug = bboxes_aug.tolist()
            bboxes_aug_corrected = []
            for box in bboxes_aug:
                min_x = min(box[0], box[2])
                min_y = min(box[1], box[3])
                max_x = max(box[0], box[2])
                max_y = max(box[1], box[3])
                bboxes_aug_corrected.append([min_y, min_x, max_y, max_x])

            if self.display:
                # print(&#34;Displaying&#34;)
                # print(image_aug)
                image_aug_with_box = image_aug.copy()
                # print(image_aug_with_box)
                for box in bboxes_aug_corrected:
                    cv2.rectangle(image_aug_with_box, (box[0], box[1]), (box[2], box[3]), (0, 0, 255), 2)
                cv2.imshow(&#39;augmented&#39;, image_aug_with_box)
                k = cv2.waitKey(0)

            # save image inside the database folder with the meta file
            aug_filename = self.set_aug_filename(file, 0)
            folder_name = os.path.basename(subdir)
            folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

            i = 0
            while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
                i += 1
                # print(&#34;File Exists : {}&#34;.format(aug_filename))
                aug_filename_ext = os.path.splitext(aug_filename)
                new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
                aug_filename = new_aug_filename

            # print(&#34;Saving to : {}&#34;.format(aug_filename))

            aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

            aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
            aug_meta = meta.copy()
            aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug_corrected
            aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)

            if not os.path.isdir(os.path.dirname(aug_meta_filepath)):
                os.mkdir(os.path.dirname(aug_meta_filepath))
                # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_meta_filepath)))

            with open(aug_meta_filepath, &#39;w&#39;) as f:
                json.dump(aug_meta, f, indent=4, sort_keys=True)
            # print(&#34;Wrote : {}&#34;.format(aug_meta_filepath))

            if not os.path.isdir(os.path.dirname(aug_image_filepath)):
                os.mkdir(os.path.dirname(aug_image_filepath))
                # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_image_filepath)))

            cv2.imwrite(aug_image_filepath, image_aug)
            # print(&#34;Wrote : {}\n&#34;.format(aug_image_filepath))

            # if self.display:


if __name__ == &#34;__main__&#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;-d&#39;, dest=&#39;display_sample&#39;, default=False)
    args = parser.parse_args()
    display_sample = args.display_sample

    # input_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase&#39;, &#39;Helipad_DataBase_original&#39;)
    # meta_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase_meta&#39;, &#39;Helipad_DataBase_meta_original&#39;)
    # root_folder = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase&#39;)
    # root_folder_meta = os.path.join(&#39;C:\\&#39;, &#39;Users&#39;, &#39;jonas&#39;, &#39;Desktop&#39;, &#39;Helipad&#39;, &#39;Helipad_DataBase_meta&#39;)

    input_folder = &#34;../../Helipad_DataBase/Helipad_DataBase_original&#34;
    meta_folder = &#34;../../Helipad_DataBase_meta/Helipad_DataBase_meta_original&#34;
    root_folder = &#34;../../Helipad_DataBase&#34;
    root_folder_meta = &#34;../../Helipad_DataBase_meta&#34;

    balance_dataset = True

    # repartition = None
    #              0  1  2  3  4  5  6  7  8  9  d  u
    repartition = [4, 4, 4, 5, 3, 4, 5, 5, 6, 6, 6, 4]

    database_augmentation = DatabaseAugmentation(input_folder,
                                                 meta_folder,
                                                 root_folder,
                                                 root_folder_meta,
                                                 balance_dataset,
                                                 repartition,
                                                 display_sample)

    database_augmentation.run()

    print(&#34;Augmentation Done!&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation"><code class="flex name class">
<span>class <span class="ident">DatabaseAugmentation</span></span>
<span>(</span><span>input_folder, meta_folder, root_folder, root_folder_meta, balance_dataset=False, repartition=None, version_number=None, display=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply Augmentation on the dataset using Google's policy </p>
<p><code>input_folder</code>: the folder containing the original images </p>
<p><code>meta_folder</code>: the folder containing the meta of the original images </p>
<p><code>root_folder</code>: the folder where to store the augmented images </p>
<p><code>root_folder_meta</code>: the folder where to store the meta of the augmented images </p>
<p><code>balance_dataset</code>: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories </p>
<p><code>repartition</code>: list of 12 integers precising the number of times each image per category is augmented
</p>
<p><code>version_number</code>: the augmentation version number. The suffix of the output folder will be the version number </p>
<p><code>display</code>: boolean to display the augmented images as the script augment them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatabaseAugmentation:
    &#34;&#34;&#34;
    Apply Augmentation on the dataset using Google&#39;s policy 
    &#34;&#34;&#34;
    def __init__(self, input_folder, meta_folder, root_folder, root_folder_meta,
                 balance_dataset=False, repartition=None, version_number=None, display=False):
        &#34;&#34;&#34;
        `input_folder`: the folder containing the original images \n
        `meta_folder`: the folder containing the meta of the original images \n
        `root_folder`: the folder where to store the augmented images \n
        `root_folder_meta`: the folder where to store the meta of the augmented images \n
        `balance_dataset`: boolean, if yes, the number of images per category is balanced by augmenting more the images from small categories \n
        `repartition`: list of 12 integers precising the number of times each image per category is augmented  \n
        `version_number`: the augmentation version number. The suffix of the output folder will be the version number \n 
        `display`: boolean to display the augmented images as the script augment them \n
        &#34;&#34;&#34;
        self.input_folder = input_folder
        self.meta_folder = meta_folder
        self.root_folder = root_folder
        self.root_folder_meta = root_folder_meta
        self.version_number = version_number
        self.aug_foldername = self.set_aug_foldername(self.root_folder, version_number=self.version_number)
        self.output_folder = os.path.join(root_folder, self.aug_foldername)
        self.aug_meta_foldername = self.set_aug_foldername(self.root_folder_meta, version_number=self.version_number)
        self.meta_output_folder = os.path.join(os.path.dirname(self.meta_folder), self.aug_meta_foldername)

        if not os.path.isdir(self.output_folder):
            os.mkdir(self.output_folder)
        if not os.path.isdir(self.meta_output_folder):
            os.mkdir(self.meta_output_folder)

        self.balance_dataset = balance_dataset
        self.repartition = repartition

        print(&#34;Building Target files&#34;)
        if self.balance_dataset:
            self.target_files = self.balance_categories(self.input_folder, self.meta_folder, repartition)
        elif repartition:
            self.target_files = self.duplicate_categories(self.input_folder, self.meta_folder, repartition)
        else:
            self.target_files = self.build_target_files()
        print(&#34;Target Files Built&#34;)
        print(&#34;Generating {} images&#34;.format(len(self.target_files)))

        if display == &#34;True&#34;:
            self.display = True
        elif display == &#34;False&#34;:
            self.display = False
        else:
            self.display = display

        print(type(self.display))
        print(&#34;Displaying samples : {}&#34;.format(self.display))
        self.sess = tf.InteractiveSession()

    @staticmethod
    def set_aug_foldername(folder, version_number=None):
        &#34;&#34;&#34;
        Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
        &#34;&#34;&#34;
        if not version_number:
            directories = os.listdir(folder)
            print(directories)
            i = 1
            for dir in directories:
                if dir[0] == &#39;.&#39;:
                    continue
                elements = dir.split(&#39;_&#39;)
                if elements[-2] == &#39;augmented&#39;:
                    i += 1
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
        else:
            aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
        return aug_foldername

    @staticmethod
    def set_aug_filename(filename, i):
        &#34;&#34;&#34;
        Set the augmentation filename using the `filename` and its augmentation id `i`.
        &#34;&#34;&#34;
        filename_ext = os.path.splitext(filename)
        aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
        return aug_filename

    @staticmethod
    def categories_imagemeta_path(input_folder, meta_folder):
        &#34;&#34;&#34;
        Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
        &#34;&#34;&#34;
        categories_path = {}
        for subdir, dirs, files in os.walk(input_folder, topdown=True):
            for file in files:
                image_path = os.path.join(subdir, file)
                meta_filepath = os.path.join(meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue
                elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

                if category not in categories_path:
                    categories_path[category] = [[image_path, meta_filepath]]
                else:
                    categories_path[category].append([image_path, meta_filepath])
        return categories_path

    @staticmethod
    def duplicate_categories(input_folder, meta_folder, repartition):
        &#34;&#34;&#34;
        Duplicate the categories respectively to the `repartition` chosen\n
        Return a list of target files
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        target_files = []

        for key, value in categories_path.items():
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat = int(key)
            if key == &#34;d&#34;:
                cat = 10
            if key == &#34;u&#34;:
                cat = 11

            for k in range(repartition[cat]):
                target_files.extend(value)

        return target_files

    @staticmethod
    def balance_categories(input_folder, meta_folder, repartition=None):
        &#34;&#34;&#34;
        Balance the categories first and then apply the `repartition` chosen \n
        Return a list of target files. 
        &#34;&#34;&#34;
        categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
        categories_count = []
        categories_count_dict = {}
        for key, value in categories_path.items():
            categories_count.append(len(value))
            categories_count_dict[key] = len(value)
        print(&#34;Categories count : &#34;, end=&#34;&#34;)
        print(categories_count)
        print(categories_count_dict)
        max_count = np.amax(categories_count)
        print(&#34;Max count : &#34;, end=&#34;&#34;)
        print(max_count)
        total_count = np.sum(categories_count)
        print(&#34;Total count : &#34;, end=&#34;&#34;)
        print(total_count)

        target_files = []

        for key, value in categories_path.items():
            target_files.extend(value)
            L = len(value)

            nb_image_to_balance = max_count-L

            # if nb_image_to_balance &lt;= L:
            #     picked_index = np.random.choice(L, nb_image_to_balance, replace=False)
            #     picked = list(np.array(value)[picked_index])
            # else:
            picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
            picked = list(np.array(value)[picked_index])
            target_files.extend(picked)

            # After Balance, duplicate categories
            if repartition:
                if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                    cat_int = int(key)
                elif key == &#34;d&#34;:
                    cat_int = 10
                elif key == &#34;u&#34;:
                    cat_int = 11

                nb_duplicate = repartition[cat_int]
                print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

                for i in range(nb_duplicate):
                    picked_index = np.random.choice(L, max_count, replace=True)
                    picked = list(np.array(value)[picked_index])
                    target_files.extend(picked)

        return target_files

    def build_target_files(self):
        &#34;&#34;&#34;
        Return a list of target files from the `input_folder`.
        &#34;&#34;&#34;
        target_files = []

        for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
            for file in files:
                meta_filepath = os.path.join(self.meta_folder,
                                             os.path.basename(subdir),
                                             os.path.splitext(file)[0]+&#34;.meta&#34;)
                with open(meta_filepath, &#39;r&#39;) as f:
                    meta = json.load(f)
                if not &#34;groundtruth&#34; in meta:
                    continue
                elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                    continue
                elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                    continue

                bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

                if len(bboxes) == 0:
                    continue

                target_files.append([os.path.join(subdir, file), meta_filepath])

        return target_files

    def run(self):
        &#34;&#34;&#34;
        Run the augmentation on the dataset after initialization
        &#34;&#34;&#34;

        for i in tqdm(range(len(self.target_files))):

            file_meta_path = self.target_files[i]

            filepath = file_meta_path[0]
            file = os.path.basename(filepath)
            subdir = os.path.dirname(filepath)
            meta_filepath = file_meta_path[1]

            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                print(&#34;{} has no box&#34;.format(file))
                continue

            # reorder boxes
            bboxes_reordered = []
            for box in bboxes:
                min_x = min(box[0], box[2])
                min_y = min(box[1], box[3])
                max_x = max(box[0], box[2])
                max_y = max(box[1], box[3])
                bboxes_reordered.append([min_y, min_x, max_y, max_x])
            bboxes_corrected = np.array(bboxes_reordered)

            image = np.asarray(cv2.imread(filepath), np.int32)
            image = tf.convert_to_tensor(image, np.int32)

            bboxes_normalized = normalize_boxes(bboxes_corrected, image.shape[:2])

            start = time.time()
            (augmented_images, augmented_bboxes) = distort_image_with_autoaugment(image, bboxes_normalized, &#39;v3&#39;)
            end = time.time()
            # print(&#34;Took : {}s to augment&#34;.format(end-start))
            augmented_bboxes = denormalize_boxes(augmented_bboxes, image.shape[:2])
            augmented_bboxes = tf.cast(augmented_bboxes, dtype=tf.int32)

            start = time.time()
            image_aug = augmented_images.numpy().astype(np.uint8)
            bboxes_aug = augmented_bboxes.numpy()
            end = time.time()
            # print(&#34;Took : {}s to retrieve results&#34;.format(end-start))
            # print(&#34;{}--&gt;{}--&gt;{}&#34;.format(bboxes, bboxes_corrected, bboxes_aug))

            bboxes_aug = bboxes_aug.tolist()
            bboxes_aug_corrected = []
            for box in bboxes_aug:
                min_x = min(box[0], box[2])
                min_y = min(box[1], box[3])
                max_x = max(box[0], box[2])
                max_y = max(box[1], box[3])
                bboxes_aug_corrected.append([min_y, min_x, max_y, max_x])

            if self.display:
                # print(&#34;Displaying&#34;)
                # print(image_aug)
                image_aug_with_box = image_aug.copy()
                # print(image_aug_with_box)
                for box in bboxes_aug_corrected:
                    cv2.rectangle(image_aug_with_box, (box[0], box[1]), (box[2], box[3]), (0, 0, 255), 2)
                cv2.imshow(&#39;augmented&#39;, image_aug_with_box)
                k = cv2.waitKey(0)

            # save image inside the database folder with the meta file
            aug_filename = self.set_aug_filename(file, 0)
            folder_name = os.path.basename(subdir)
            folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

            i = 0
            while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
                i += 1
                # print(&#34;File Exists : {}&#34;.format(aug_filename))
                aug_filename_ext = os.path.splitext(aug_filename)
                new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
                aug_filename = new_aug_filename

            # print(&#34;Saving to : {}&#34;.format(aug_filename))

            aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

            aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
            aug_meta = meta.copy()
            aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug_corrected
            aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)

            if not os.path.isdir(os.path.dirname(aug_meta_filepath)):
                os.mkdir(os.path.dirname(aug_meta_filepath))
                # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_meta_filepath)))

            with open(aug_meta_filepath, &#39;w&#39;) as f:
                json.dump(aug_meta, f, indent=4, sort_keys=True)
            # print(&#34;Wrote : {}&#34;.format(aug_meta_filepath))

            if not os.path.isdir(os.path.dirname(aug_image_filepath)):
                os.mkdir(os.path.dirname(aug_image_filepath))
                # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_image_filepath)))

            cv2.imwrite(aug_image_filepath, image_aug)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.balance_categories"><code class="name flex">
<span>def <span class="ident">balance_categories</span></span>(<span>input_folder, meta_folder, repartition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Balance the categories first and then apply the <code>repartition</code> chosen </p>
<p>Return a list of target files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def balance_categories(input_folder, meta_folder, repartition=None):
    &#34;&#34;&#34;
    Balance the categories first and then apply the `repartition` chosen \n
    Return a list of target files. 
    &#34;&#34;&#34;
    categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
    categories_count = []
    categories_count_dict = {}
    for key, value in categories_path.items():
        categories_count.append(len(value))
        categories_count_dict[key] = len(value)
    print(&#34;Categories count : &#34;, end=&#34;&#34;)
    print(categories_count)
    print(categories_count_dict)
    max_count = np.amax(categories_count)
    print(&#34;Max count : &#34;, end=&#34;&#34;)
    print(max_count)
    total_count = np.sum(categories_count)
    print(&#34;Total count : &#34;, end=&#34;&#34;)
    print(total_count)

    target_files = []

    for key, value in categories_path.items():
        target_files.extend(value)
        L = len(value)

        nb_image_to_balance = max_count-L

        # if nb_image_to_balance &lt;= L:
        #     picked_index = np.random.choice(L, nb_image_to_balance, replace=False)
        #     picked = list(np.array(value)[picked_index])
        # else:
        picked_index = np.random.choice(L, nb_image_to_balance, replace=True)
        picked = list(np.array(value)[picked_index])
        target_files.extend(picked)

        # After Balance, duplicate categories
        if repartition:
            if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
                cat_int = int(key)
            elif key == &#34;d&#34;:
                cat_int = 10
            elif key == &#34;u&#34;:
                cat_int = 11

            nb_duplicate = repartition[cat_int]
            print(&#34;Duplicating category {} {} times&#34;.format(key, nb_duplicate))

            for i in range(nb_duplicate):
                picked_index = np.random.choice(L, max_count, replace=True)
                picked = list(np.array(value)[picked_index])
                target_files.extend(picked)

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.categories_imagemeta_path"><code class="name flex">
<span>def <span class="ident">categories_imagemeta_path</span></span>(<span>input_folder, meta_folder)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def categories_imagemeta_path(input_folder, meta_folder):
    &#34;&#34;&#34;
    Returns a dictionnary having a category as a key and a list of tuples (image_path, meta_filepath) belonging to this category as value.
    &#34;&#34;&#34;
    categories_path = {}
    for subdir, dirs, files in os.walk(input_folder, topdown=True):
        for file in files:
            image_path = os.path.join(subdir, file)
            meta_filepath = os.path.join(meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)
            if not &#34;groundtruth&#34; in meta:
                continue
            elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                continue
            elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                continue
            elif &#34;category&#34; not in meta[&#34;groundtruth&#34;]:
                continue

            category = meta[&#34;groundtruth&#34;][&#34;category&#34;]

            if category not in categories_path:
                categories_path[category] = [[image_path, meta_filepath]]
            else:
                categories_path[category].append([image_path, meta_filepath])
    return categories_path</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.duplicate_categories"><code class="name flex">
<span>def <span class="ident">duplicate_categories</span></span>(<span>input_folder, meta_folder, repartition)</span>
</code></dt>
<dd>
<div class="desc"><p>Duplicate the categories respectively to the <code>repartition</code> chosen</p>
<p>Return a list of target files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def duplicate_categories(input_folder, meta_folder, repartition):
    &#34;&#34;&#34;
    Duplicate the categories respectively to the `repartition` chosen\n
    Return a list of target files
    &#34;&#34;&#34;
    categories_path = DatabaseAugmentation.categories_imagemeta_path(input_folder, meta_folder)
    target_files = []

    for key, value in categories_path.items():
        if &#34;0&#34; &lt;= key &lt;= &#34;9&#34;:
            cat = int(key)
        if key == &#34;d&#34;:
            cat = 10
        if key == &#34;u&#34;:
            cat = 11

        for k in range(repartition[cat]):
            target_files.extend(value)

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_filename"><code class="name flex">
<span>def <span class="ident">set_aug_filename</span></span>(<span>filename, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the augmentation filename using the <code>filename</code> and its augmentation id <code>i</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_aug_filename(filename, i):
    &#34;&#34;&#34;
    Set the augmentation filename using the `filename` and its augmentation id `i`.
    &#34;&#34;&#34;
    filename_ext = os.path.splitext(filename)
    aug_filename = filename_ext[0]+&#34;_aug_{:03d}&#34;.format(i)+filename_ext[1]
    return aug_filename</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_foldername"><code class="name flex">
<span>def <span class="ident">set_aug_foldername</span></span>(<span>folder, version_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the augmented folder name with the suffix <code>version_number</code>. The output folder is a sub-directory of <code>folder</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_aug_foldername(folder, version_number=None):
    &#34;&#34;&#34;
    Set the augmented folder name with the suffix `version_number`. The output folder is a sub-directory of `folder`. 
    &#34;&#34;&#34;
    if not version_number:
        directories = os.listdir(folder)
        print(directories)
        i = 1
        for dir in directories:
            if dir[0] == &#39;.&#39;:
                continue
            elements = dir.split(&#39;_&#39;)
            if elements[-2] == &#39;augmented&#39;:
                i += 1
        aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(i)
    else:
        aug_foldername = os.path.basename(folder)+&#34;_augmented_{}&#34;.format(version_number)
    return aug_foldername</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.build_target_files"><code class="name flex">
<span>def <span class="ident">build_target_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of target files from the <code>input_folder</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_target_files(self):
    &#34;&#34;&#34;
    Return a list of target files from the `input_folder`.
    &#34;&#34;&#34;
    target_files = []

    for subdir, dirs, files in os.walk(self.input_folder, topdown=True):
        for file in files:
            meta_filepath = os.path.join(self.meta_folder,
                                         os.path.basename(subdir),
                                         os.path.splitext(file)[0]+&#34;.meta&#34;)
            with open(meta_filepath, &#39;r&#39;) as f:
                meta = json.load(f)
            if not &#34;groundtruth&#34; in meta:
                continue
            elif not meta[&#34;groundtruth&#34;][&#34;helipad&#34;]:
                continue
            elif &#34;box&#34; not in meta[&#34;groundtruth&#34;]:
                continue

            bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

            if len(bboxes) == 0:
                continue

            target_files.append([os.path.join(subdir, file), meta_filepath])

    return target_files</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the augmentation on the dataset after initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the augmentation on the dataset after initialization
    &#34;&#34;&#34;

    for i in tqdm(range(len(self.target_files))):

        file_meta_path = self.target_files[i]

        filepath = file_meta_path[0]
        file = os.path.basename(filepath)
        subdir = os.path.dirname(filepath)
        meta_filepath = file_meta_path[1]

        with open(meta_filepath, &#39;r&#39;) as f:
            meta = json.load(f)

        bboxes = meta[&#34;groundtruth&#34;][&#34;box&#34;]

        if len(bboxes) == 0:
            print(&#34;{} has no box&#34;.format(file))
            continue

        # reorder boxes
        bboxes_reordered = []
        for box in bboxes:
            min_x = min(box[0], box[2])
            min_y = min(box[1], box[3])
            max_x = max(box[0], box[2])
            max_y = max(box[1], box[3])
            bboxes_reordered.append([min_y, min_x, max_y, max_x])
        bboxes_corrected = np.array(bboxes_reordered)

        image = np.asarray(cv2.imread(filepath), np.int32)
        image = tf.convert_to_tensor(image, np.int32)

        bboxes_normalized = normalize_boxes(bboxes_corrected, image.shape[:2])

        start = time.time()
        (augmented_images, augmented_bboxes) = distort_image_with_autoaugment(image, bboxes_normalized, &#39;v3&#39;)
        end = time.time()
        # print(&#34;Took : {}s to augment&#34;.format(end-start))
        augmented_bboxes = denormalize_boxes(augmented_bboxes, image.shape[:2])
        augmented_bboxes = tf.cast(augmented_bboxes, dtype=tf.int32)

        start = time.time()
        image_aug = augmented_images.numpy().astype(np.uint8)
        bboxes_aug = augmented_bboxes.numpy()
        end = time.time()
        # print(&#34;Took : {}s to retrieve results&#34;.format(end-start))
        # print(&#34;{}--&gt;{}--&gt;{}&#34;.format(bboxes, bboxes_corrected, bboxes_aug))

        bboxes_aug = bboxes_aug.tolist()
        bboxes_aug_corrected = []
        for box in bboxes_aug:
            min_x = min(box[0], box[2])
            min_y = min(box[1], box[3])
            max_x = max(box[0], box[2])
            max_y = max(box[1], box[3])
            bboxes_aug_corrected.append([min_y, min_x, max_y, max_x])

        if self.display:
            # print(&#34;Displaying&#34;)
            # print(image_aug)
            image_aug_with_box = image_aug.copy()
            # print(image_aug_with_box)
            for box in bboxes_aug_corrected:
                cv2.rectangle(image_aug_with_box, (box[0], box[1]), (box[2], box[3]), (0, 0, 255), 2)
            cv2.imshow(&#39;augmented&#39;, image_aug_with_box)
            k = cv2.waitKey(0)

        # save image inside the database folder with the meta file
        aug_filename = self.set_aug_filename(file, 0)
        folder_name = os.path.basename(subdir)
        folder_augmented = folder_name[:len(folder_name)-3] + &#34;augmented_&#34; + folder_name[len(folder_name)-3:]

        i = 0
        while os.path.isfile(os.path.join(self.output_folder, folder_augmented, aug_filename)):
            i += 1
            # print(&#34;File Exists : {}&#34;.format(aug_filename))
            aug_filename_ext = os.path.splitext(aug_filename)
            new_aug_filename = aug_filename_ext[0][:len(aug_filename_ext[0])-3]+&#34;{:03d}&#34;.format(i)+aug_filename_ext[1]
            aug_filename = new_aug_filename

        # print(&#34;Saving to : {}&#34;.format(aug_filename))

        aug_image_filepath = os.path.join(self.output_folder, folder_augmented, aug_filename)

        aug_meta_filename = os.path.splitext(aug_filename)[0] + &#34;.meta&#34;
        aug_meta = meta.copy()
        aug_meta[&#34;groundtruth&#34;][&#34;box&#34;] = bboxes_aug_corrected
        aug_meta_filepath = os.path.join(self.meta_output_folder, folder_augmented, aug_meta_filename)

        if not os.path.isdir(os.path.dirname(aug_meta_filepath)):
            os.mkdir(os.path.dirname(aug_meta_filepath))
            # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_meta_filepath)))

        with open(aug_meta_filepath, &#39;w&#39;) as f:
            json.dump(aug_meta, f, indent=4, sort_keys=True)
        # print(&#34;Wrote : {}&#34;.format(aug_meta_filepath))

        if not os.path.isdir(os.path.dirname(aug_image_filepath)):
            os.mkdir(os.path.dirname(aug_image_filepath))
            # print(&#34;Created directory : {}&#34;.format(os.path.dirname(aug_image_filepath)))

        cv2.imwrite(aug_image_filepath, image_aug)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.database_management" href="index.html">helipad_detection.src.database_management</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation">DatabaseAugmentation</a></code></h4>
<ul class="">
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.balance_categories" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.balance_categories">balance_categories</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.build_target_files" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.build_target_files">build_target_files</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.categories_imagemeta_path" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.categories_imagemeta_path">categories_imagemeta_path</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.duplicate_categories" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.duplicate_categories">duplicate_categories</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.run" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.run">run</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_filename" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_filename">set_aug_filename</a></code></li>
<li><code><a title="helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_foldername" href="#helipad_detection.src.database_management.database_augmentation.DatabaseAugmentation.set_aug_foldername">set_aug_foldername</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>