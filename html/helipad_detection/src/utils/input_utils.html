<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>helipad_detection.src.utils.input_utils API documentation</title>
<meta name="description" content="Utility functions for input processing." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helipad_detection.src.utils.input_utils</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for input processing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Lint as: python2, python3
# Copyright 2019 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
&#34;&#34;&#34;Utility functions for input processing.&#34;&#34;&#34;

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import math
from six.moves import range
import tensorflow.compat.v1 as tf

from helipad_detection.src.utils import box_utils
# from helipad_detection.src.utils.object_detection import preprocessor


def pad_to_fixed_size(input_tensor, size, constant_values=0):
  &#34;&#34;&#34;Pads data to a fixed length at the first dimension.

  Args:
    input_tensor: `Tensor` with any dimension.
    size: `int` number for the first dimension of output Tensor.
    constant_values: `int` value assigned to the paddings.

  Returns:
    `Tensor` with the first dimension padded to `size`.
  &#34;&#34;&#34;
  input_shape = input_tensor.get_shape().as_list()
  padding_shape = []

  # Computes the padding length on the first dimension.
  padding_length = tf.maximum(0, size - tf.shape(input_tensor)[0])
  assert_length = tf.Assert(
      tf.greater_equal(padding_length, 0), [padding_length])
  with tf.control_dependencies([assert_length]):
    padding_shape.append(padding_length)

  # Copies shapes of the rest of input shape dimensions.
  for i in range(1, len(input_shape)):
    padding_shape.append(tf.shape(input_tensor)[i])

  # Pads input tensor to the fixed first dimension.
  paddings = tf.cast(constant_values * tf.ones(padding_shape),
                     input_tensor.dtype)
  padded_tensor = tf.concat([input_tensor, paddings], axis=0)
  output_shape = input_shape
  output_shape[0] = size
  padded_tensor.set_shape(output_shape)
  return padded_tensor


def normalize_image(image,
                    offset=(0.485, 0.456, 0.406),
                    scale=(0.229, 0.224, 0.225)):
  &#34;&#34;&#34;Normalizes the image to zero mean and unit variance.&#34;&#34;&#34;
  image = tf.image.convert_image_dtype(image, dtype=tf.float32)
  offset = tf.constant(offset)
  offset = tf.expand_dims(offset, axis=0)
  offset = tf.expand_dims(offset, axis=0)
  image -= offset

  scale = tf.constant(scale)
  scale = tf.expand_dims(scale, axis=0)
  scale = tf.expand_dims(scale, axis=0)
  image /= scale
  return image


def compute_padded_size(desired_size, stride):
  &#34;&#34;&#34;Compute the padded size given the desired size and the stride.

  The padded size will be the smallest rectangle, such that each dimension is
  the smallest multiple of the stride which is larger than the desired
  dimension. For example, if desired_size = (100, 200) and stride = 32,
  the output padded_size = (128, 224).

  Args:
    desired_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the target output image size.
    stride: an integer, the stride of the backbone network.

  Returns:
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size.
  &#34;&#34;&#34;
  if isinstance(desired_size, list) or isinstance(desired_size, tuple):
    padded_size = [int(math.ceil(d * 1.0 / stride) * stride)
                   for d in desired_size]
  else:
    padded_size = tf.cast(
        tf.math.ceil(
            tf.cast(desired_size, dtype=tf.float32) / stride) * stride,
        tf.int32)
  return padded_size


def resize_and_crop_image(image,
                          desired_size,
                          padded_size,
                          aug_scale_min=1.0,
                          aug_scale_max=1.0,
                          seed=1,
                          method=tf.image.ResizeMethod.BILINEAR):
  &#34;&#34;&#34;Resizes the input image to output size (RetinaNet style).

  Resize and pad images given the desired output size of the image and
  stride size.

  Here are the preprocessing steps.
  1. For a given image, keep its aspect ratio and rescale the image to make it
     the largest rectangle to be bounded by the rectangle specified by the
     `desired_size`.
  2. Pad the rescaled image to the padded_size.

  Args:
    image: a `Tensor` of shape [height, width, 3] representing an image.
    desired_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the desired actual output image size.
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size. Padding will be applied
      after scaling the image to the desired_size.
    aug_scale_min: a `float` with range between [0, 1.0] representing minimum
      random scale applied to desired_size for training scale jittering.
    aug_scale_max: a `float` with range between [1.0, inf] representing maximum
      random scale applied to desired_size for training scale jittering.
    seed: seed for random scale jittering.
    method: function to resize input image to scaled image.

  Returns:
    output_image: `Tensor` of shape [height, width, 3] where [height, width]
      equals to `output_size`.
    image_info: a 2D `Tensor` that encodes the information of the image and the
      applied preprocessing. It is in the format of
      [[original_height, original_width], [scaled_height, scaled_width],
       [y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
      scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
      the scaling factor, which is the ratio of
      scaled dimension / original dimension.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_image&#39;):
    image_size = tf.cast(tf.shape(image)[0:2], tf.float32)

    random_jittering = (aug_scale_min != 1.0 or aug_scale_max != 1.0)

    if random_jittering:
      random_scale = tf.random_uniform(
          [], aug_scale_min, aug_scale_max, seed=seed)
      scaled_size = tf.round(random_scale * desired_size)
    else:
      scaled_size = desired_size

    scale = tf.minimum(
        scaled_size[0] / image_size[0], scaled_size[1] / image_size[1])
    scaled_size = tf.round(image_size * scale)

    # Computes 2D image_scale.
    image_scale = scaled_size / image_size

    # Selects non-zero random offset (x, y) if scaled image is larger than
    # desired_size.
    if random_jittering:
      max_offset = scaled_size - desired_size
      max_offset = tf.where(tf.less(max_offset, 0),
                            tf.zeros_like(max_offset),
                            max_offset)
      offset = max_offset * tf.random_uniform([2,], 0, 1, seed=seed)
      offset = tf.cast(offset, tf.int32)
    else:
      offset = tf.zeros((2,), tf.int32)

    scaled_image = tf.image.resize_images(
        image, tf.cast(scaled_size, tf.int32), method=method)

    if random_jittering:
      scaled_image = scaled_image[
          offset[0]:offset[0] + desired_size[0],
          offset[1]:offset[1] + desired_size[1], :]

    output_image = tf.image.pad_to_bounding_box(
        scaled_image, 0, 0, padded_size[0], padded_size[1])

    image_info = tf.stack([
        image_size,
        scaled_size,
        image_scale,
        tf.cast(offset, tf.float32)])
    return output_image, image_info


def resize_and_crop_image_v2(image,
                             short_side,
                             long_side,
                             padded_size,
                             aug_scale_min=1.0,
                             aug_scale_max=1.0,
                             seed=1,
                             method=tf.image.ResizeMethod.BILINEAR):
  &#34;&#34;&#34;Resizes the input image to output size (Faster R-CNN style).

  Resize and pad images given the specified short / long side length and the
  stride size.

  Here are the preprocessing steps.
  1. For a given image, keep its aspect ratio and first try to rescale the short
     side of the original image to `short_side`.
  2. If the scaled image after 1 has a long side that exceeds `long_side`, keep
     the aspect ratio and rescal the long side of the image to `long_side`.
  2. Pad the rescaled image to the padded_size.

  Args:
    image: a `Tensor` of shape [height, width, 3] representing an image.
    short_side: a scalar `Tensor` or `int` representing the desired short side
      to be rescaled to.
    long_side: a scalar `Tensor` or `int` representing the desired long side to
      be rescaled to.
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size. Padding will be applied
      after scaling the image to the desired_size.
    aug_scale_min: a `float` with range between [0, 1.0] representing minimum
      random scale applied to desired_size for training scale jittering.
    aug_scale_max: a `float` with range between [1.0, inf] representing maximum
      random scale applied to desired_size for training scale jittering.
    seed: seed for random scale jittering.
    method: function to resize input image to scaled image.

  Returns:
    output_image: `Tensor` of shape [height, width, 3] where [height, width]
      equals to `output_size`.
    image_info: a 2D `Tensor` that encodes the information of the image and the
      applied preprocessing. It is in the format of
      [[original_height, original_width], [scaled_height, scaled_width],
       [y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
      scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
      the scaling factor, which is the ratio of
      scaled dimension / original dimension.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_image_v2&#39;):
    image_size = tf.cast(tf.shape(image)[0:2], tf.float32)

    scale_using_short_side = (
        short_side / tf.minimum(image_size[0], image_size[1]))
    scale_using_long_side = (
        long_side / tf.maximum(image_size[0], image_size[1]))

    scaled_size = tf.round(image_size * scale_using_short_side)
    scaled_size = tf.where(
        tf.greater(tf.maximum(scaled_size[0], scaled_size[1]), long_side),
        tf.round(image_size * scale_using_long_side),
        scaled_size)
    desired_size = scaled_size

    random_jittering = (aug_scale_min != 1.0 or aug_scale_max != 1.0)

    if random_jittering:
      random_scale = tf.random_uniform(
          [], aug_scale_min, aug_scale_max, seed=seed)
      scaled_size = tf.round(random_scale * scaled_size)

    # Computes 2D image_scale.
    image_scale = scaled_size / image_size

    # Selects non-zero random offset (x, y) if scaled image is larger than
    # desired_size.
    if random_jittering:
      max_offset = scaled_size - desired_size
      max_offset = tf.where(tf.less(max_offset, 0),
                            tf.zeros_like(max_offset),
                            max_offset)
      offset = max_offset * tf.random_uniform([2,], 0, 1, seed=seed)
      offset = tf.cast(offset, tf.int32)
    else:
      offset = tf.zeros((2,), tf.int32)

    scaled_image = tf.image.resize_images(
        image, tf.cast(scaled_size, tf.int32), method=method)

    if random_jittering:
      scaled_image = scaled_image[
          offset[0]:offset[0] + desired_size[0],
          offset[1]:offset[1] + desired_size[1], :]

    output_image = tf.image.pad_to_bounding_box(
        scaled_image, 0, 0, padded_size[0], padded_size[1])

    image_info = tf.stack([
        image_size,
        scaled_size,
        image_scale,
        tf.cast(offset, tf.float32)])
    return output_image, image_info


def resize_and_crop_boxes(boxes,
                          image_scale,
                          output_size,
                          offset):
  &#34;&#34;&#34;Resizes boxes to output size with scale and offset.

  Args:
    boxes: `Tensor` of shape [N, 4] representing ground truth boxes.
    image_scale: 2D float `Tensor` representing scale factors that apply to
      [height, width] of input image.
    output_size: 2D `Tensor` or `int` representing [height, width] of target
      output image size.
    offset: 2D `Tensor` representing top-left corner [y0, x0] to crop scaled
      boxes.

  Returns:
    boxes: `Tensor` of shape [N, 4] representing the scaled boxes.
  &#34;&#34;&#34;
  # Adjusts box coordinates based on image_scale and offset.
  boxes *= tf.tile(tf.expand_dims(image_scale, axis=0), [1, 2])
  boxes -= tf.tile(tf.expand_dims(offset, axis=0), [1, 2])
  # Clips the boxes.
  boxes = box_utils.clip_boxes(boxes, output_size)
  return boxes


def resize_and_crop_masks(masks,
                          image_scale,
                          output_size,
                          offset):
  &#34;&#34;&#34;Resizes boxes to output size with scale and offset.

  Args:
    masks: `Tensor` of shape [N, H, W, 1] representing ground truth masks.
    image_scale: 2D float `Tensor` representing scale factors that apply to
      [height, width] of input image.
    output_size: 2D `Tensor` or `int` representing [height, width] of target
      output image size.
    offset: 2D `Tensor` representing top-left corner [y0, x0] to crop scaled
      boxes.

  Returns:
    masks: `Tensor` of shape [N, H, W, 1] representing the scaled masks.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_masks&#39;):
    mask_size = tf.cast(tf.shape(masks)[1:3], tf.float32)
    # Pad masks to avoid empty mask annotations.
    masks = tf.concat([tf.zeros([1, mask_size[0], mask_size[1], 1]),
                       masks], axis=0)

    scaled_size = tf.cast(image_scale * mask_size, tf.int32)
    scaled_masks = tf.image.resize_images(
        masks, scaled_size, method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)
    offset = tf.cast(offset, tf.int32)
    scaled_masks = scaled_masks[
        :, offset[0]:offset[0] + output_size[0],
        offset[1]:offset[1] + output_size[1], :]

    output_masks = tf.image.pad_to_bounding_box(
        scaled_masks, 0, 0, output_size[0], output_size[1])
    # Remove padding.
    output_masks = output_masks[1::]
    return output_masks


def random_horizontal_flip(image, boxes=None, masks=None):
  &#34;&#34;&#34;Randomly flips input image and bounding boxes.&#34;&#34;&#34;
  return preprocessor.random_horizontal_flip(image, boxes, masks)


def get_non_empty_box_indices(boxes):
  &#34;&#34;&#34;Get indices for non-empty boxes.&#34;&#34;&#34;
  # Selects indices if box height or width is 0.
  height = boxes[:, 2] - boxes[:, 0]
  width = boxes[:, 3] - boxes[:, 1]
  indices = tf.where(tf.logical_and(tf.greater(height, 0),
                                    tf.greater(width, 0)))
  return indices[:, 0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="helipad_detection.src.utils.input_utils.compute_padded_size"><code class="name flex">
<span>def <span class="ident">compute_padded_size</span></span>(<span>desired_size, stride)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the padded size given the desired size and the stride.</p>
<p>The padded size will be the smallest rectangle, such that each dimension is
the smallest multiple of the stride which is larger than the desired
dimension. For example, if desired_size = (100, 200) and stride = 32,
the output padded_size = (128, 224).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_size</code></strong></dt>
<dd>a <code>Tensor</code> or <code>int</code> list/tuple of two elements representing
[height, width] of the target output image size.</dd>
<dt><strong><code>stride</code></strong></dt>
<dd>an integer, the stride of the backbone network.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>padded_size</code></dt>
<dd>a <code>Tensor</code> or <code>int</code> list/tuple of two elements representing
[height, width] of the padded output image size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_padded_size(desired_size, stride):
  &#34;&#34;&#34;Compute the padded size given the desired size and the stride.

  The padded size will be the smallest rectangle, such that each dimension is
  the smallest multiple of the stride which is larger than the desired
  dimension. For example, if desired_size = (100, 200) and stride = 32,
  the output padded_size = (128, 224).

  Args:
    desired_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the target output image size.
    stride: an integer, the stride of the backbone network.

  Returns:
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size.
  &#34;&#34;&#34;
  if isinstance(desired_size, list) or isinstance(desired_size, tuple):
    padded_size = [int(math.ceil(d * 1.0 / stride) * stride)
                   for d in desired_size]
  else:
    padded_size = tf.cast(
        tf.math.ceil(
            tf.cast(desired_size, dtype=tf.float32) / stride) * stride,
        tf.int32)
  return padded_size</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.get_non_empty_box_indices"><code class="name flex">
<span>def <span class="ident">get_non_empty_box_indices</span></span>(<span>boxes)</span>
</code></dt>
<dd>
<div class="desc"><p>Get indices for non-empty boxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_non_empty_box_indices(boxes):
  &#34;&#34;&#34;Get indices for non-empty boxes.&#34;&#34;&#34;
  # Selects indices if box height or width is 0.
  height = boxes[:, 2] - boxes[:, 0]
  width = boxes[:, 3] - boxes[:, 1]
  indices = tf.where(tf.logical_and(tf.greater(height, 0),
                                    tf.greater(width, 0)))
  return indices[:, 0]</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.normalize_image"><code class="name flex">
<span>def <span class="ident">normalize_image</span></span>(<span>image, offset=(0.485, 0.456, 0.406), scale=(0.229, 0.224, 0.225))</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes the image to zero mean and unit variance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_image(image,
                    offset=(0.485, 0.456, 0.406),
                    scale=(0.229, 0.224, 0.225)):
  &#34;&#34;&#34;Normalizes the image to zero mean and unit variance.&#34;&#34;&#34;
  image = tf.image.convert_image_dtype(image, dtype=tf.float32)
  offset = tf.constant(offset)
  offset = tf.expand_dims(offset, axis=0)
  offset = tf.expand_dims(offset, axis=0)
  image -= offset

  scale = tf.constant(scale)
  scale = tf.expand_dims(scale, axis=0)
  scale = tf.expand_dims(scale, axis=0)
  image /= scale
  return image</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.pad_to_fixed_size"><code class="name flex">
<span>def <span class="ident">pad_to_fixed_size</span></span>(<span>input_tensor, size, constant_values=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Pads data to a fixed length at the first dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_tensor</code></strong></dt>
<dd><code>Tensor</code> with any dimension.</dd>
<dt><strong><code>size</code></strong></dt>
<dd><code>int</code> number for the first dimension of output Tensor.</dd>
<dt><strong><code>constant_values</code></strong></dt>
<dd><code>int</code> value assigned to the paddings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> with the first dimension padded to <code>size</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_to_fixed_size(input_tensor, size, constant_values=0):
  &#34;&#34;&#34;Pads data to a fixed length at the first dimension.

  Args:
    input_tensor: `Tensor` with any dimension.
    size: `int` number for the first dimension of output Tensor.
    constant_values: `int` value assigned to the paddings.

  Returns:
    `Tensor` with the first dimension padded to `size`.
  &#34;&#34;&#34;
  input_shape = input_tensor.get_shape().as_list()
  padding_shape = []

  # Computes the padding length on the first dimension.
  padding_length = tf.maximum(0, size - tf.shape(input_tensor)[0])
  assert_length = tf.Assert(
      tf.greater_equal(padding_length, 0), [padding_length])
  with tf.control_dependencies([assert_length]):
    padding_shape.append(padding_length)

  # Copies shapes of the rest of input shape dimensions.
  for i in range(1, len(input_shape)):
    padding_shape.append(tf.shape(input_tensor)[i])

  # Pads input tensor to the fixed first dimension.
  paddings = tf.cast(constant_values * tf.ones(padding_shape),
                     input_tensor.dtype)
  padded_tensor = tf.concat([input_tensor, paddings], axis=0)
  output_shape = input_shape
  output_shape[0] = size
  padded_tensor.set_shape(output_shape)
  return padded_tensor</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.random_horizontal_flip"><code class="name flex">
<span>def <span class="ident">random_horizontal_flip</span></span>(<span>image, boxes=None, masks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly flips input image and bounding boxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_horizontal_flip(image, boxes=None, masks=None):
  &#34;&#34;&#34;Randomly flips input image and bounding boxes.&#34;&#34;&#34;
  return preprocessor.random_horizontal_flip(image, boxes, masks)</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.resize_and_crop_boxes"><code class="name flex">
<span>def <span class="ident">resize_and_crop_boxes</span></span>(<span>boxes, image_scale, output_size, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Resizes boxes to output size with scale and offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boxes</code></strong></dt>
<dd><code>Tensor</code> of shape [N, 4] representing ground truth boxes.</dd>
<dt><strong><code>image_scale</code></strong></dt>
<dd>2D float <code>Tensor</code> representing scale factors that apply to
[height, width] of input image.</dd>
<dt><strong><code>output_size</code></strong></dt>
<dd>2D <code>Tensor</code> or <code>int</code> representing [height, width] of target
output image size.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>2D <code>Tensor</code> representing top-left corner [y0, x0] to crop scaled
boxes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boxes</code></dt>
<dd><code>Tensor</code> of shape [N, 4] representing the scaled boxes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_and_crop_boxes(boxes,
                          image_scale,
                          output_size,
                          offset):
  &#34;&#34;&#34;Resizes boxes to output size with scale and offset.

  Args:
    boxes: `Tensor` of shape [N, 4] representing ground truth boxes.
    image_scale: 2D float `Tensor` representing scale factors that apply to
      [height, width] of input image.
    output_size: 2D `Tensor` or `int` representing [height, width] of target
      output image size.
    offset: 2D `Tensor` representing top-left corner [y0, x0] to crop scaled
      boxes.

  Returns:
    boxes: `Tensor` of shape [N, 4] representing the scaled boxes.
  &#34;&#34;&#34;
  # Adjusts box coordinates based on image_scale and offset.
  boxes *= tf.tile(tf.expand_dims(image_scale, axis=0), [1, 2])
  boxes -= tf.tile(tf.expand_dims(offset, axis=0), [1, 2])
  # Clips the boxes.
  boxes = box_utils.clip_boxes(boxes, output_size)
  return boxes</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.resize_and_crop_image"><code class="name flex">
<span>def <span class="ident">resize_and_crop_image</span></span>(<span>image, desired_size, padded_size, aug_scale_min=1.0, aug_scale_max=1.0, seed=1, method=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Resizes the input image to output size (RetinaNet style).</p>
<p>Resize and pad images given the desired output size of the image and
stride size.</p>
<p>Here are the preprocessing steps.
1. For a given image, keep its aspect ratio and rescale the image to make it
the largest rectangle to be bounded by the rectangle specified by the
<code>desired_size</code>.
2. Pad the rescaled image to the padded_size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>a <code>Tensor</code> of shape [height, width, 3] representing an image.</dd>
<dt><strong><code>desired_size</code></strong></dt>
<dd>a <code>Tensor</code> or <code>int</code> list/tuple of two elements representing
[height, width] of the desired actual output image size.</dd>
<dt><strong><code>padded_size</code></strong></dt>
<dd>a <code>Tensor</code> or <code>int</code> list/tuple of two elements representing
[height, width] of the padded output image size. Padding will be applied
after scaling the image to the desired_size.</dd>
<dt><strong><code>aug_scale_min</code></strong></dt>
<dd>a <code>float</code> with range between [0, 1.0] representing minimum
random scale applied to desired_size for training scale jittering.</dd>
<dt><strong><code>aug_scale_max</code></strong></dt>
<dd>a <code>float</code> with range between [1.0, inf] representing maximum
random scale applied to desired_size for training scale jittering.</dd>
<dt><strong><code>seed</code></strong></dt>
<dd>seed for random scale jittering.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>function to resize input image to scaled image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_image</code></dt>
<dd><code>Tensor</code> of shape [height, width, 3] where [height, width]
equals to <code>output_size</code>.</dd>
<dt><code>image_info</code></dt>
<dd>a 2D <code>Tensor</code> that encodes the information of the image and the
applied preprocessing. It is in the format of
[[original_height, original_width], [scaled_height, scaled_width],
[y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
the scaling factor, which is the ratio of
scaled dimension / original dimension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_and_crop_image(image,
                          desired_size,
                          padded_size,
                          aug_scale_min=1.0,
                          aug_scale_max=1.0,
                          seed=1,
                          method=tf.image.ResizeMethod.BILINEAR):
  &#34;&#34;&#34;Resizes the input image to output size (RetinaNet style).

  Resize and pad images given the desired output size of the image and
  stride size.

  Here are the preprocessing steps.
  1. For a given image, keep its aspect ratio and rescale the image to make it
     the largest rectangle to be bounded by the rectangle specified by the
     `desired_size`.
  2. Pad the rescaled image to the padded_size.

  Args:
    image: a `Tensor` of shape [height, width, 3] representing an image.
    desired_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the desired actual output image size.
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size. Padding will be applied
      after scaling the image to the desired_size.
    aug_scale_min: a `float` with range between [0, 1.0] representing minimum
      random scale applied to desired_size for training scale jittering.
    aug_scale_max: a `float` with range between [1.0, inf] representing maximum
      random scale applied to desired_size for training scale jittering.
    seed: seed for random scale jittering.
    method: function to resize input image to scaled image.

  Returns:
    output_image: `Tensor` of shape [height, width, 3] where [height, width]
      equals to `output_size`.
    image_info: a 2D `Tensor` that encodes the information of the image and the
      applied preprocessing. It is in the format of
      [[original_height, original_width], [scaled_height, scaled_width],
       [y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
      scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
      the scaling factor, which is the ratio of
      scaled dimension / original dimension.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_image&#39;):
    image_size = tf.cast(tf.shape(image)[0:2], tf.float32)

    random_jittering = (aug_scale_min != 1.0 or aug_scale_max != 1.0)

    if random_jittering:
      random_scale = tf.random_uniform(
          [], aug_scale_min, aug_scale_max, seed=seed)
      scaled_size = tf.round(random_scale * desired_size)
    else:
      scaled_size = desired_size

    scale = tf.minimum(
        scaled_size[0] / image_size[0], scaled_size[1] / image_size[1])
    scaled_size = tf.round(image_size * scale)

    # Computes 2D image_scale.
    image_scale = scaled_size / image_size

    # Selects non-zero random offset (x, y) if scaled image is larger than
    # desired_size.
    if random_jittering:
      max_offset = scaled_size - desired_size
      max_offset = tf.where(tf.less(max_offset, 0),
                            tf.zeros_like(max_offset),
                            max_offset)
      offset = max_offset * tf.random_uniform([2,], 0, 1, seed=seed)
      offset = tf.cast(offset, tf.int32)
    else:
      offset = tf.zeros((2,), tf.int32)

    scaled_image = tf.image.resize_images(
        image, tf.cast(scaled_size, tf.int32), method=method)

    if random_jittering:
      scaled_image = scaled_image[
          offset[0]:offset[0] + desired_size[0],
          offset[1]:offset[1] + desired_size[1], :]

    output_image = tf.image.pad_to_bounding_box(
        scaled_image, 0, 0, padded_size[0], padded_size[1])

    image_info = tf.stack([
        image_size,
        scaled_size,
        image_scale,
        tf.cast(offset, tf.float32)])
    return output_image, image_info</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.resize_and_crop_image_v2"><code class="name flex">
<span>def <span class="ident">resize_and_crop_image_v2</span></span>(<span>image, short_side, long_side, padded_size, aug_scale_min=1.0, aug_scale_max=1.0, seed=1, method=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Resizes the input image to output size (Faster R-CNN style).</p>
<p>Resize and pad images given the specified short / long side length and the
stride size.</p>
<p>Here are the preprocessing steps.
1. For a given image, keep its aspect ratio and first try to rescale the short
side of the original image to <code>short_side</code>.
2. If the scaled image after 1 has a long side that exceeds <code>long_side</code>, keep
the aspect ratio and rescal the long side of the image to <code>long_side</code>.
2. Pad the rescaled image to the padded_size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>a <code>Tensor</code> of shape [height, width, 3] representing an image.</dd>
<dt><strong><code>short_side</code></strong></dt>
<dd>a scalar <code>Tensor</code> or <code>int</code> representing the desired short side
to be rescaled to.</dd>
<dt><strong><code>long_side</code></strong></dt>
<dd>a scalar <code>Tensor</code> or <code>int</code> representing the desired long side to
be rescaled to.</dd>
<dt><strong><code>padded_size</code></strong></dt>
<dd>a <code>Tensor</code> or <code>int</code> list/tuple of two elements representing
[height, width] of the padded output image size. Padding will be applied
after scaling the image to the desired_size.</dd>
<dt><strong><code>aug_scale_min</code></strong></dt>
<dd>a <code>float</code> with range between [0, 1.0] representing minimum
random scale applied to desired_size for training scale jittering.</dd>
<dt><strong><code>aug_scale_max</code></strong></dt>
<dd>a <code>float</code> with range between [1.0, inf] representing maximum
random scale applied to desired_size for training scale jittering.</dd>
<dt><strong><code>seed</code></strong></dt>
<dd>seed for random scale jittering.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>function to resize input image to scaled image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_image</code></dt>
<dd><code>Tensor</code> of shape [height, width, 3] where [height, width]
equals to <code>output_size</code>.</dd>
<dt><code>image_info</code></dt>
<dd>a 2D <code>Tensor</code> that encodes the information of the image and the
applied preprocessing. It is in the format of
[[original_height, original_width], [scaled_height, scaled_width],
[y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
the scaling factor, which is the ratio of
scaled dimension / original dimension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_and_crop_image_v2(image,
                             short_side,
                             long_side,
                             padded_size,
                             aug_scale_min=1.0,
                             aug_scale_max=1.0,
                             seed=1,
                             method=tf.image.ResizeMethod.BILINEAR):
  &#34;&#34;&#34;Resizes the input image to output size (Faster R-CNN style).

  Resize and pad images given the specified short / long side length and the
  stride size.

  Here are the preprocessing steps.
  1. For a given image, keep its aspect ratio and first try to rescale the short
     side of the original image to `short_side`.
  2. If the scaled image after 1 has a long side that exceeds `long_side`, keep
     the aspect ratio and rescal the long side of the image to `long_side`.
  2. Pad the rescaled image to the padded_size.

  Args:
    image: a `Tensor` of shape [height, width, 3] representing an image.
    short_side: a scalar `Tensor` or `int` representing the desired short side
      to be rescaled to.
    long_side: a scalar `Tensor` or `int` representing the desired long side to
      be rescaled to.
    padded_size: a `Tensor` or `int` list/tuple of two elements representing
      [height, width] of the padded output image size. Padding will be applied
      after scaling the image to the desired_size.
    aug_scale_min: a `float` with range between [0, 1.0] representing minimum
      random scale applied to desired_size for training scale jittering.
    aug_scale_max: a `float` with range between [1.0, inf] representing maximum
      random scale applied to desired_size for training scale jittering.
    seed: seed for random scale jittering.
    method: function to resize input image to scaled image.

  Returns:
    output_image: `Tensor` of shape [height, width, 3] where [height, width]
      equals to `output_size`.
    image_info: a 2D `Tensor` that encodes the information of the image and the
      applied preprocessing. It is in the format of
      [[original_height, original_width], [scaled_height, scaled_width],
       [y_scale, x_scale], [y_offset, x_offset]], where [scaled_height,
      scaled_width] is the actual scaled image size, and [y_scale, x_scale] is
      the scaling factor, which is the ratio of
      scaled dimension / original dimension.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_image_v2&#39;):
    image_size = tf.cast(tf.shape(image)[0:2], tf.float32)

    scale_using_short_side = (
        short_side / tf.minimum(image_size[0], image_size[1]))
    scale_using_long_side = (
        long_side / tf.maximum(image_size[0], image_size[1]))

    scaled_size = tf.round(image_size * scale_using_short_side)
    scaled_size = tf.where(
        tf.greater(tf.maximum(scaled_size[0], scaled_size[1]), long_side),
        tf.round(image_size * scale_using_long_side),
        scaled_size)
    desired_size = scaled_size

    random_jittering = (aug_scale_min != 1.0 or aug_scale_max != 1.0)

    if random_jittering:
      random_scale = tf.random_uniform(
          [], aug_scale_min, aug_scale_max, seed=seed)
      scaled_size = tf.round(random_scale * scaled_size)

    # Computes 2D image_scale.
    image_scale = scaled_size / image_size

    # Selects non-zero random offset (x, y) if scaled image is larger than
    # desired_size.
    if random_jittering:
      max_offset = scaled_size - desired_size
      max_offset = tf.where(tf.less(max_offset, 0),
                            tf.zeros_like(max_offset),
                            max_offset)
      offset = max_offset * tf.random_uniform([2,], 0, 1, seed=seed)
      offset = tf.cast(offset, tf.int32)
    else:
      offset = tf.zeros((2,), tf.int32)

    scaled_image = tf.image.resize_images(
        image, tf.cast(scaled_size, tf.int32), method=method)

    if random_jittering:
      scaled_image = scaled_image[
          offset[0]:offset[0] + desired_size[0],
          offset[1]:offset[1] + desired_size[1], :]

    output_image = tf.image.pad_to_bounding_box(
        scaled_image, 0, 0, padded_size[0], padded_size[1])

    image_info = tf.stack([
        image_size,
        scaled_size,
        image_scale,
        tf.cast(offset, tf.float32)])
    return output_image, image_info</code></pre>
</details>
</dd>
<dt id="helipad_detection.src.utils.input_utils.resize_and_crop_masks"><code class="name flex">
<span>def <span class="ident">resize_and_crop_masks</span></span>(<span>masks, image_scale, output_size, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Resizes boxes to output size with scale and offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>masks</code></strong></dt>
<dd><code>Tensor</code> of shape [N, H, W, 1] representing ground truth masks.</dd>
<dt><strong><code>image_scale</code></strong></dt>
<dd>2D float <code>Tensor</code> representing scale factors that apply to
[height, width] of input image.</dd>
<dt><strong><code>output_size</code></strong></dt>
<dd>2D <code>Tensor</code> or <code>int</code> representing [height, width] of target
output image size.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>2D <code>Tensor</code> representing top-left corner [y0, x0] to crop scaled
boxes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>masks</code></dt>
<dd><code>Tensor</code> of shape [N, H, W, 1] representing the scaled masks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_and_crop_masks(masks,
                          image_scale,
                          output_size,
                          offset):
  &#34;&#34;&#34;Resizes boxes to output size with scale and offset.

  Args:
    masks: `Tensor` of shape [N, H, W, 1] representing ground truth masks.
    image_scale: 2D float `Tensor` representing scale factors that apply to
      [height, width] of input image.
    output_size: 2D `Tensor` or `int` representing [height, width] of target
      output image size.
    offset: 2D `Tensor` representing top-left corner [y0, x0] to crop scaled
      boxes.

  Returns:
    masks: `Tensor` of shape [N, H, W, 1] representing the scaled masks.
  &#34;&#34;&#34;
  with tf.name_scope(&#39;resize_and_crop_masks&#39;):
    mask_size = tf.cast(tf.shape(masks)[1:3], tf.float32)
    # Pad masks to avoid empty mask annotations.
    masks = tf.concat([tf.zeros([1, mask_size[0], mask_size[1], 1]),
                       masks], axis=0)

    scaled_size = tf.cast(image_scale * mask_size, tf.int32)
    scaled_masks = tf.image.resize_images(
        masks, scaled_size, method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)
    offset = tf.cast(offset, tf.int32)
    scaled_masks = scaled_masks[
        :, offset[0]:offset[0] + output_size[0],
        offset[1]:offset[1] + output_size[1], :]

    output_masks = tf.image.pad_to_bounding_box(
        scaled_masks, 0, 0, output_size[0], output_size[1])
    # Remove padding.
    output_masks = output_masks[1::]
    return output_masks</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helipad_detection.src.utils" href="index.html">helipad_detection.src.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="helipad_detection.src.utils.input_utils.compute_padded_size" href="#helipad_detection.src.utils.input_utils.compute_padded_size">compute_padded_size</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.get_non_empty_box_indices" href="#helipad_detection.src.utils.input_utils.get_non_empty_box_indices">get_non_empty_box_indices</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.normalize_image" href="#helipad_detection.src.utils.input_utils.normalize_image">normalize_image</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.pad_to_fixed_size" href="#helipad_detection.src.utils.input_utils.pad_to_fixed_size">pad_to_fixed_size</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.random_horizontal_flip" href="#helipad_detection.src.utils.input_utils.random_horizontal_flip">random_horizontal_flip</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.resize_and_crop_boxes" href="#helipad_detection.src.utils.input_utils.resize_and_crop_boxes">resize_and_crop_boxes</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.resize_and_crop_image" href="#helipad_detection.src.utils.input_utils.resize_and_crop_image">resize_and_crop_image</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.resize_and_crop_image_v2" href="#helipad_detection.src.utils.input_utils.resize_and_crop_image_v2">resize_and_crop_image_v2</a></code></li>
<li><code><a title="helipad_detection.src.utils.input_utils.resize_and_crop_masks" href="#helipad_detection.src.utils.input_utils.resize_and_crop_masks">resize_and_crop_masks</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>